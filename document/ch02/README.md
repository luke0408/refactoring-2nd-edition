# Ch02. 리팩터링 원칙

Chapter 1에서 리팩터링이 무엇인지 충분히 감을 잡아보았다.

이를 토대로 이번 장에서는 리팩터링 전반에 적용되는 원칙 몇가지를 설명한다.

## 2.1 리팩터링 정의

> 누군가 "리팩터링하다 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링 한 것이 아니다.

수많은 다른 소프트웨어 개발 용어와 마찬가지로 리팩터링(Refactoring)도 엔지니어들 사이에서 다소 두리뭉실한 의미로 사용됩니다. 하지만, 마틴 파울러는 리팩터링의 의미를 더 구체적으로, 다소 엄격하게 정의함으로써 더 유용하게 사용하고자 합니다.

> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

앞 장에서 본 함수 추출하기와 조건부 로직을 다형성으로 바꾸기 처럼 이름 붙은 리팩터링 기법들이 위 정의에 해당합니다.

> 리팩터링(하다): [동사] 소프트웨어의 걷보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

지금껏 저는 책에서 소개하는 여느 사람들처럼 코드를 정리하는 작업을 모조리 "리팩터링"이라고 표현해왔습니다. 하지만, 마틴 파울러는 위에서 정의한 의미와 같이 `특정한 방식에 따라 코드를 정리하는 것 만이 리팩터링이다`라고 설명하고 있죠.

즉, 이전 챕터에서 했던 것 처럼 리팩터링은 아주 작은 단위로 단계를 나누어 쌓아가는 것임으로 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있습니다.

### 리팩터링 vs 성능 최적화

리팩터링과 성능 최적화는 둘 다 코드를 변경하며 프로그램의 전반적인 기능은 그대로 유지하지만, 그 목적이 상이합니다.

리팩터링의 목적은 `코드를 이해하고 수정하기 쉽게 만드는 것`으로, 프로그램의 성능이 나빠지거나 좋아질 수 있습니다.

반면 성능 최적화는 오로지 속도 개선에만 신경을 씁니다. 때문에 목표 성능에 반드시 도달해야 한다면 코드를 다루기에 더 어렵게 수정할수도 있습니다.

## 2.2 두 개의 모자

켄트 백은 개발의 목적 분리 작업을 두 개의 모자에 비유합니다. 

기능을 추가할 때는 "기능 추가" 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 합니다. 진척도는 `테스트를 추가해서 통과하는지 확인`하는 방식으로 진행합니다.

또한, 리팩터링을 할 때에는 "리팩터링" 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념합니다. 이때는 앞 과정에서 놓친 테스트 케이스를 발견한게 아닌 이상 `테스트를 추가하지 않습니다.` 

이러한 각각의 작업시간은 10분 미만으로 짧을 수 있습니다. 그럼에도 마틴 파울러는 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인지할 것을 권장합니다.

## 2.3 리팩터링하는 이유

리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 아니지만, 코드를 건강한 상태로 유지하는 데 도움을 주는 약입니다.

### 리팩터링하면 소프트웨어 설계가 좋아진다.

리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 섞기 쉽습니다. 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉬워지며, 그러면 코드만으론 설계를 이해하기 어려워집니다. 

이런 방식으로 우리의 코드와 설계는 부패되기 시작합니다. 이를 방지하기 위해 리팩터링을 해야하죠.

같은 일을 하더라도 설계가 나쁘면 코드가 길어집니다. 사실상 같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문인데요. 때문에 우리는 중복 코드를 제거하는 걸 중요하게 생각합니다.

물론 코드량을 줄이는 것이 성능 향상이랑 항상 직결되진 않습니다. 다만 중복 코드를 줄이면 `모든 코드가 항상 고유한 일을 수행함을 보장`할 수 있으며, 이는 바람직한 설계의 핵심입니다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

컴퓨터는 우리가 시킬 일을 코드를 통해 작성하면 정확히 그대로 반응합니다. 이 처럼 프로그래밍은 컴퓨터와 우리가 대화하는 것과 같기 때문에 "컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야" 합니다.

프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일인거죠. 문제는 우리가 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못하게 됩니다.

코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화(리팩터링)를 줘야합니다. 잘 작동하지만 구조가 이상한 코드가 있다면, 잠시 시간을 내어 리팩터링을 한다던가 말이죠.

이러한 배려는 사실 다른 사람을 위해서 하는 일이 아닙니다. 대부분의 경우 미래의 나 자신을 위한 일이죠. 예를 들어 1년전 과거의 자신이 작성했던 코드로 돌아가보시죠. 우선 저는 과거의 코드가 왜 이렇게 작성되었는지 이해하지 못 했습니다.

즉, 우리는 모든 코드를 기억하지 않을 뿐더러 기억하지 못 합니다. 때문에, 마틴 파울러는 기억할 필요가 있는 것들은 최대한 코드에 담아둘 것을 권장합니다.

### 리팩터링하면 버그를 쉽게 찾을 수 있다.

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말 입니다. 리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 됩니다.

프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해집니다.

### 리팩터링하면 프로그래밍 속도를 높일 수 있다.

지금까지 제시한 장점을 한마디로 정리하면 다음과 같습니다.

> 리팩터링을 하면 코드 개발 속도를 높일 수 있다.

얼핏 그 반대가 아닌가 생각할 수 있습니다. 대부분 리팩터링이 내부 설계와 코드 퀄리티를 높일 수 있다는 점은 대부분 숭은 하지만, 리팩터링을 하는데 시간이 드니 전체 개발 속도가 떨어질까 걱정 할 수도 있습니다.

한 시스템을 오래 개발하는 개발자들과 얘기하다 보면 초기에는 진척이 빨랐지만 현재는 새 기능을 하나 추가하는데 훨씬 오래 걸린다는 말을 많이합니다.

새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이죠.

게다가 기능을 추가하다보면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸리게 됩니다. 

코드베이스는 패치에 패치가 덧붙여지면서 프로그램의 동작을 파악하기가 더욱 어려워지고, 이러한 부담이 점점 늘어나다보면 차라리 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 다다르게 됩니다.

하지만 좋은 설계를 지닌 팀은 기존에 작성한 코드를 최대한 활요할 수 있어서 새 기능을 더 빨리 추가하는게 가능해집니다.

이렇게 차이 나는 원인은 소프트웨어의 내부 품질에 있습니다.

내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 때 모듈화가 잘되어있어서 코드의 작성 포인트를 쉽게 찾을 수 있으며, 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉬워집니다.

결과적으로 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕게되는 것이죠.

마틴 파울러는 이 효과를 설계 지구력 가설 (Design Stamina Hypothesis) 라고 부릅니다. 이는 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다는 것을 의미합니다.

## 2.4 언제 리팩터링해야 할까?

>`3의 법칙`
>
> 돈 로버츠(Don Roberts)가 제시한 가이드
> 
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다면) 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링 한다.
>

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전입니다. 해당 시점의 현 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기 쉬워질 만한 부분을 찾아봅니다.

예를 들면 모든 요구사을 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있을 수 있습니다.

이때, 함수를 복제해서 해당 값만 수정해도 되지만, 그러면 중복 코드가 생깁니다. 이는 이후에 해당 기능을 수정할 일이 생긴다면 수정 포인트가 여러개가 될 가능성을 내포함으로 수정해야합니다.

그래서 이럴 때에는 리팩터링 모자를 쓰고 "함수 매개변수화하기"를 적용합니다. 그러면 나중에 그 함수에 필요한 매개변수를 지정해서 호출하기만 하면 되죠.

버그를 잡을 때에도 마찬가지입니다. 오류를 이르키는 코드가 몇 곳에 복제되어 퍼져있다면 오류 발생 코드를 하나로 합치는 편이 작업하기 편해집니다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 코드를 파악해야합니다.

마틴 파울러는 조건부 로직의 구조가 이상하지는 않은지, 함수 이름을 잘못 설정하지 않았는지 등 코드의 의도가 명확하게 들어날 수 있도록 리팩터링할 수 있는지의 관점에서 살펴 보는 것을 추천합니다.

이렇게 관점을 담아 읽어보는 것 만으로 충분히 도움이 되지만 실제로 리팩터링을 하면서 읽는 것도 좋습니다. 

> "리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인 할 수 있다" <br> - 위드 커닝햄(ward cunningham)

이렇게 리팩터링하면 하지 않았을 때보다 더 깊은 수준으로 코드를 이해할 수 있게 됩니다.

### 쓰레기 줍기 리팩터링

코드를 파악하던 주에 일을 비효율적으로 처리하는 모습을 발견할 때가 많습니다. 로직이 쓸데없이 복잡하거나, 매개변후화한 함수 하나면 될 일을 거의 똑같이 함수 여러개로 작성했을 가능성도 있습니다.

이때는 절충이 필요합니다.

원래 하던 작업과 관련 없는 일에 너무 많은 시간을 쓰기 싫지만, 그렇다고 쓰레기가 나뒹굴게 방치하는 것도 일에 방해가 되니 좋지 않습니다.

간단하게 해결 가능하다면 그자리에서 해결하면 되겠지만, 그렇지 않다면 이후를 위해 메모해두고 일을 끝낸 뒤에 처리를 하면 좋습니다. 예를들어 `TODO:` 와 같은 comment를 남기는 것이 대표적이겠죠.

물론 수정하려면 몇 시간이나 걸리고 당장 더 급한 일이 있을 수 있습니다. 그럼에도 캠핑 규칙(항상 처음 왔을 때보다 깔끔하게 정리하고 떠나자.)을 습관처럼 지켜봅시다.

### 계획된 리팩터링과 수시로 하는 리팩터링

앞에서 본 "준비를 위한 리팩터링", "이해를 위한 리팩터링", "쓰레기 줍기 리팩터링"은 모두 기회가 될 때만 진행하게 됩니다.

마틴 파울러는 개발을 들어갈 때 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링을 함께 합니다. 이는 프로그래밍 과정에 자연스럽게 리팩터링을 녹인 것이죠.

리팩터링은 프로그래밍과 구분되는 별개의 활동이 아닙니다.

흔히 리팩터링을 과거에 저지른 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기도 합니다. 보기 싫은 코드를 보면 리팩터링 함은 당연하지만 잘 작성된 코드 역시 수 많은 리팩터링을 거쳐야 합니다.

오랫동안 사람들은 소프트웨어 개발이 무언가를 "추가"하는 과정으로 여겨왔습니다. `하지만 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 "수정"하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음`을 압니다.

소프트웨어 개발은 끝이 없습니다. 새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정됩니다. 이때, 새로운 코드보다 기존 코드의 수정량이 더 큰 경우도 대체로 많죠.

수시로 리팩터링을 해야하지만 계획된 리팩터링도 필요한 경우가 물론 있습니다. 그동한 리팩터링에 소홀 했다면 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있습니다.

### 오래 걸리는 리팩터링

리팩터링은 대부분 몇 분안에 길어야 몇 시간 정도 안에 끝나는 일입니다. 하지만, 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있습니다.

라이브러리를 새로 교체하는 작업일 수 있고, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트를 빼내는 작업일 수 있습니다. 또는 그동안 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업 일 수도 있겠죠.

이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 일이 발생하거나 그럴 것 같다면 한번 고민을 해보아야 합니다. "정말 당장의 작업을 중단하고 리팩터링에 매달려야 하는가?" 라고 말이죠.

리팩터링은 코드를 깨트리지 않는다는 장점이 있습니다. 일부를 변경해도 모든 기능이 항상 올바르게 작동해야하죠.

예컨대 라이브러리를 바꾸는 일이라면 기존 것과 새로운 것 모두 포용하는 추상인터페이스를 만들고 기존 코드가 추상 인터페이스를 호출하도록 하면 라이브러리를 훨씬 쉽게 고칠 수 있습니다.


### 코드 리뷰에 리팩터링 활용하기

코드 리뷰를 정기적으로 수행하는 조직도 있습니다. 그렇지 않은 조직이라면 해보는 걸 추천드립니다.

코드 리뷰는 다음과 같은 장점을 가집니다.

- 개발팀 전체에 지식을 전파하기 좋음
- 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수하기 좋음
- 대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람들이 이해하는데 도움을 줌
- 코드를 건강하게 유지하는게 도움을 줌
- 다른 사람의 아이디어를 얻을 수 있음

그러므로 기회가 닿는 대로 코드 리뷰를 하는걸 추천드립니다.

그리고 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움이 됩니다. 리팩터링을 활용하기 전에는 코드를 읽고, 그럭저럭 이해한 뒤 몇가지 개선 사항을 제시했습니다.

마틴 파울러는 새로운 아이디어가 떠오르면 먼저 리팩터링을 통해 쉽게 구현해넣을 수 있는지 살펴보고, 쉽다면 실제로 리팩터링을 진행합니다. 

이 과정을 통해 내가 생각한 아이디어를 적용했을 떄의 모습을 더 명확하게 만들 수 있다합니다. 가끔은 그러지 않았다면 절때 떠올릴 수 없는 한 차원 높은 아이디어를 떠올리기도 한다죠.

결과적으로 리팩터링은 개선안들을 제시하는 데서 그치지 않고, 그 중 상당수를 즉시 구현해볼 수 있게 만듭니다. 이는 코드 리뷰의 결과를 더 구체적으로 도출하는데 도움을 준다는 뜻이죠.

또한, 마틴 파울러는 코드 리뷰를 할 때에는 `코드 작성자가 참여하는` 형태의 리뷰 진행 방식을 추천합니다. 코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있기 때문입니다.

### 리팩터링을 하지 말아야할 때

지금까지의 이야기만 들으면 무조건 리팩터링을 해야한다고 들릴 수도 있지만, 그러면 안되는 경우도 있습니다.

- 외부 API 다루듯 호출해서 사용하는 코드
- 리팩터링을 하는 것보다 처음부터 다시하는게 나은 경우

전자의 경우 내부 동작을 이해해야 할 시점에 리팩터링을 해야 효과를 볼 수 있기 때문입니다.

후자의 경우는 상황이 조금 다릅니다. 판단하기 쉽지 않을 뿐더러 많은 경험이 뒷받침 되어야하기 때문이죠. 대다수 직접 리팩터링을 해보기 전에는 어느것이 쉬운지 확실하게 알기 어렵습니다.

## 2.5 리팩터링 시 고려할 문제

리팩터링은 많은 팀에서 적극적으로 도입해야 할 중요한 기법이지만 리팩터링에도 문제점이 없는 것은 아닙니다.

즉, 우리는 이런 문제가 언제 발생하고 어떻게 대처해야 하는지 반드시 알고 있어야합니다.

### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목표는 개발 속도를 높여서, 더 작은 노력으로 더 많은 가치를 창출하는 것이다.

위 말처럼 리팩터링은 더 적은 노력으로 가치를 창출하기 위한 것입니다. 그럼에도 저를 포함한 많은 사람들은 리팩터링을 '클린 코드'나 '바람직한 엔지니어링 습관'처럼 도덕적인 이유로 정당화하는 오류에 빠지곤 합니다.

리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않으며, 오로지 경제적인 이류로 하는 것입니다. 리팩터링은 개발 기간을 단축하고자 하는 것으로 기능 추가 시간을 줄이고, 버그 수정 시간을 줄이는데 도움을 줍니다.

위 본질을 잊어버린다면 리팩터링이라는 도구는 경제적인 목적을 달성하기 위한 도구가 아니라 "클린 코드"를 위한 도덕적이고 예술적인 도구가 되어버립니다. 이 경우 리팩터링은 기능 개발 속도 저하의 주범이 되어버리죠.

때문에 우린 이런 오류를 범하지 않도록 항상 리팩터링의 목적을 명확히 해야합니다.

### 코드 소유권

리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많습니다.

그러다 보면 코드 소유권의 문제를 마주치기도 하죠.

- 함수 이름을 바꾸고 싶어서 함수를 호출하는 곳을 모두 찾아서 바꿀 수도 있지만 그 코드의 소유자가 다른 팀인 경우
- 바꾸고 싶은 함수가 고객에게 API로 제공된 기능인 경우

등등 위 처럼 코드의 소유관은 리팩터링에 영향을 주기 때문에 마틴 파울러는 코드 소유권을 작은 단위로 나누는 것을 반대합니다. 대신 코드 소유권을 팀에 두는 것을 추천합니다.

이렇게하면 팀원의 누구나 팀이 소유한 코드를 수정할 수 있습니다. 물론 프로그래머마다 각자가 책임지는 영역이 있을 수 있습니다. 하지만 이는 자신이 맡은 영역의 변경 사항을 관리하라는 말이지, 다른 사람이 수정하지 못하게 막으라는 뜻이 아닙니다.

예를 들어 자신이 담당한 코드라고 하여 팀원이 PR도 못 올리게 하면 안되겠죠?

### 브랜치

현재 흔히 볼 수 있는 팀 단위 작업 방식은 버전 관리 시스템을 통해 팀원마다 코드 베이스를 하나씩 맡아서 작업하다가 결과물이 쌓이면 마스터 브랜치에 통합하는 방식입니다.

이렇게 하면 기능 전체를 한 브랜치에다 구현해놓고 프로덕션이 버전으로 릴리스 할 때가 되서야 마스터에 통합하는 경우가 많죠. 이 방식을 선호하는 분들은 마스터 브랜치를 건강하게 관리할 수 있어서 좋다고 합니다.

하지만 각기 다른 독립 브랜치의 작업 기간이 길어질수록 마스터와 통합하기 어려워진다는 단점도 있습니다.

이 고통을 줄이기 위해 마스터를 개인 브랜치로 수시로 리베이스 하거나 머지하죠. 그럼에도 여러 브랜치에서 동시에 개발이 진행될 땐 이런식으로 해결할 수 없습니다.

그렇기에 책에서는 머지와 통합을 명확히 나누는 법을 제시합니다.

| 방법 | 방향성 | 결과 |
| --- | --- | --- |
| 머지 | 단방향 (마스터 -> 브랜치)  | 브랜치만 바뀌고 마스터는 그대로 |
| 통합 | 양방향 (마스터 <-> 브랜치) | 마스터를 개인 브랜치로 가져와서 작업한 결과를 다시 마스터로 올리기 때문에 둘다 바뀜.|

통합의 경우 다른 브랜치에서 함수를 호출하는 코드를 추가했는데, 내 브랜치에서 그 함수의 이름을 변경했다면 프로그램이 동작하지 않는 문제가 발생합니다.

이처럼 머지가 복잡해지는 문제는 기간이 길어질 수록늘어납니다. 때문에 기능별 브랜치의 통합 주기를 2~3일을 가져가야하거나 더 짧게 가져가야야 한다는 의견을 내는 사람들이 있습니다. 이를 `지속적 통합(Continous Intergration, CI)`, 또는 `트렁크 기반 개발(Trunk-Based Development, TBD)`이라 합니다.

CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합해야하며, 그렇게 함으로 브랜치 간의 차이를 줄여 머지 복잡도를 낮출 수 있습니다.

### 테스팅

리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것입니다. 절차를 지켜 리팩터링을 하면 동작이 깨지지 않아야 하며, 실수를 저질러 동작이 깨지더라도 금방 복구하는게 가능해집니다.

여기서 핵심은 `오류를 빨리 잡는 것`에 있습니다. 이를 위해서는 코드의 다양한 측면을 감시하는 다양한 Test Suite가 필요합니다. 달리 말하면 대부분의 경우 리팩터링을 위해서는 자가 테스트 코드(Self-testing code)를 마련해야한다는 것입니다.

이런 자가 테스트 코드를 작성하는 습관은 리팩터링의 안정성과 버그가 생길 수 있다는 불안감에서 우리를 해소 시켜줍니다.

그렇다면 테스트가 필요하지 않는 경우는 언제가 있을까요? 그것은 바로 뛰어난 자동 리팩터링을 제공하는 환경에서 작업을 진행할 때 입니다.

검증된 안전한 자동 리팩터링을 사용하면 오류가 발생하지 않을 수 있으며, 이 때문에 테스트 없이 검증된 몇 가지 리팩터링 기법만을 조합해 사용하자는 흐름도 있습니다.

이 경우 각 단계를 신중하게 진행해야 하며 언어별로 구체적인 방법도 달라집니다.

### 레거시 코드

사람들은 대부분 많이 물려받을수록 좋아하는 경향이 있습니다. 하지만 프로그래밍을 할 땐 그렇지 않죠.

물려받은 레거시 코드는 대체로 복잡하고 테스트도 제대로 갖춰지지 않은 것이 많습니다. 무엇보다 다른 사람이 작성했죠.

이런 레거시 코드를 파악할 때에도 리팩터링이 굉장히 도움됩니다. 제 기능과 맞지 않는 함수 이름을 바로 잡고 어설픈 프로그램 구문을 매끄럽게 다듬어서 거친 원석을 보석 처럼 바꿀 수도 있습니다. 하지만, 테스트 코드가 없는 레거시 코드에서는 불가능에 가까운 이야기죠.

즉, 문제의 정답은 테스트 보강입니다.

[레거시 코드 활용 전략](https://product.kyobobook.co.kr/detail/S000001804724)에 따르면 "프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다"고 합니다. 그리고 이러한 틈새를 만들때 리팩터링이 사용되는 것이죠.

물론 테스트가 있더라도 복잡하게 얽힌 레거시 코드를 한번에 아름다운 코드로 바꾸는 낙관적인 일은 없습니다. 때문에 서로 관련된 부분끼리 나눠서 하나씩 공략해야 합니다.

전부는 아니더라도 코드의 한부분을 흝고 넘어갈 때 마다 예전보다 조금이라도 개선하려고 노력하는 것이죠. 자주 읽는 코드 일수록 중요한 부분이라는 것이기 때문에 그 부분이라도 개선하자는 것입니다.

### 데이터 베이스

진화형 데이터베이스 설계와 데이터베이스 리팩터링과 같은 기법들이 현재 널리 적용되고 있습니다. 위 기법의 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데에 있습니다.

간단한 예로 필드의 이름을 변경하는 경우 함수 선언 바꾸기에 따르면 데이터의 구조를 원래 선언과 이 데이터 구조를 호출하는 코드를 모두 찾아서 한번에 변경해야합니다.

이때 예전 필드를 사용하는 데이터 모두가 새 필드를 사용하도록 반환해야하는 부담도 따르게 되죠.

이때 이 변환을 수행하는 코드를 간단히 작성한 다음, 선언된 데이터 구조나 접근 루틴을 변경하는 코드와 함께 버전 관리시스템에 저장합니다.

이후 다음 데이터베이스를 다른 버전으로 이전할 때마다 현재 버전에서 원하는 버전 사이에 있는 모든 마이그레이션 스크립트를 실행합니다.

이처럼 다른 리팩터링과 마찬가지로 이 기법도 `전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심`입니다.

단, 데이터베이스 리팩터링은 프로덕션 환경에서 여러 단계로 나눠서 릴리스 하는 것이 대체로 좋다는 점이 다릅니다. 이렇게 함으로써 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉬워집니다.

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

일단 코드로 작성된 뒤로는 아키텍처를 바꿀 수 없고 부주의로 인해 부패할 일만 남았다고 여겼기에 초기의 프로그래밍은 코딩을 시작하기 전에 소프트웨어 설계와 아키텍처를 어느정도, 심지어 거의 완료해야 하는게 정설이었습니다.

리팩터링은 이러한 관점을 크게 바꾸어 두었습니다. 리팩터링은 기존의 설계를 개선할 수 있게 만들며, 아키책처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해 주었습니다.

코딩 전에 아키택처를 확정지으려 할 때의 가장 큰 문제점은 정말 원하는 바를 이해하고 있지 못하면서 소프트웨어의 요구사항을 사전에 모두 파악해야한다는 것입니다.

당연히 할 수 없는 일이기에 우리는 `유연성 메커니즘`을 소프트웨어에 심어두기도 합니다.

가령 함수를 정의하다 보면 범용적으로 사용할 수 있겠다는 생각이 들 때가 있습니다. 그래서 다양한 예상 시나리오에 대응하기 위해 매개변수를 추가하곤 하죠. 이런 매개변수들이 유연성 메커니즘입니다.

간혹 유연성 메커니즘을 잘 못 구현하는 경우가 생깁니다. 요구사항이 처음과 바뀌어서 일수도, 설계한 메커니즘 자체의 결함 때문일수도 있습니다. 이런 모든 상황을 고려하다 보면 유연성 메커니즘은 오히려 변화에 대응하는 능력을 떨어뜨리는 방향으로 동작하게 됩니다.

리팩터링은 이런 문제를 해결해줍니다. 미래에 대한 변화와 유연성을 추측하지 않고, 현재의 요구 사항만을 해결하는 소프트웨어를 구축합니다. 이후 사용자의 요구사항을 더 잘 이해하게 되면 그 때 아키택처를 리팩터링합니다.

이런 설계 방식을 간결한 설계, 점진적 설계 또는 YAGNI("you aren't going to need it", 필요 없을 거다)라고 부릅니다.
