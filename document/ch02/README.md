# Ch02. 리팩터링 원칙

Chapter 1에서 리팩터링이 무엇인지 충분히 감을 잡아보았다.

이를 토대로 이번 장에서는 리팩터링 전반에 적용되는 원칙 몇가지를 설명한다.

## 2.1 리팩터링 정의

> 누군가 "리팩터링하다 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링 한 것이 아니다.

수많은 다른 소프트웨어 개발 용어와 마찬가지로 리팩터링(Refactoring)도 엔지니어들 사이에서 다소 두리뭉실한 의미로 사용됩니다. 하지만, 마틴 파울러는 리팩터링의 의미를 더 구체적으로, 다소 엄격하게 정의함으로써 더 유용하게 사용하고자 합니다.

> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

앞 장에서 본 함수 추출하기와 조건부 로직을 다형성으로 바꾸기 처럼 이름 붙은 리팩터링 기법들이 위 정의에 해당합니다.

> 리팩터링(하다): [동사] 소프트웨어의 걷보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

지금껏 저는 책에서 소개하는 여느 사람들처럼 코드를 정리하는 작업을 모조리 "리팩터링"이라고 표현해왔습니다. 하지만, 마틴 파울러는 위에서 정의한 의미와 같이 `특정한 방식에 따라 코드를 정리하는 것 만이 리팩터링이다`라고 설명하고 있죠.

즉, 이전 챕터에서 했던 것 처럼 리팩터링은 아주 작은 단위로 단계를 나누어 쌓아가는 것임으로 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있습니다.

### 리팩터링 vs 성능 최적화

리팩터링과 성능 최적화는 둘 다 코드를 변경하며 프로그램의 전반적인 기능은 그대로 유지하지만, 그 목적이 상이합니다.

리팩터링의 목적은 `코드를 이해하고 수정하기 쉽게 만드는 것`으로, 프로그램의 성능이 나빠지거나 좋아질 수 있습니다.

반면 성능 최적화는 오로지 속도 개선에만 신경을 씁니다. 때문에 목표 성능에 반드시 도달해야 한다면 코드를 다루기에 더 어렵게 수정할수도 있습니다.

## 2.2 두 개의 모자

켄트 백은 개발의 목적 분리 작업을 두 개의 모자에 비유합니다. 

기능을 추가할 때는 "기능 추가" 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 합니다. 진척도는 `테스트를 추가해서 통과하는지 확인`하는 방식으로 진행합니다.

또한, 리팩터링을 할 때에는 "리팩터링" 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념합니다. 이때는 앞 과정에서 놓친 테스트 케이스를 발견한게 아닌 이상 `테스트를 추가하지 않습니다.` 

이러한 각각의 작업시간은 10분 미만으로 짧을 수 있습니다. 그럼에도 마틴 파울러는 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인지할 것을 권장합니다.

## 2.3 리팩터링하는 이유

리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 아니지만, 코드를 건강한 상태로 유지하는 데 도움을 주는 약입니다.

### 리팩터링하면 소프트웨어 설계가 좋아진다.

리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 섞기 쉽습니다. 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉬워지며, 그러면 코드만으론 설계를 이해하기 어려워집니다. 

이런 방식으로 우리의 코드와 설계는 부패되기 시작합니다. 이를 방지하기 위해 리팩터링을 해야하죠.

같은 일을 하더라도 설계가 나쁘면 코드가 길어집니다. 사실상 같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문인데요. 때문에 우리는 중복 코드를 제거하는 걸 중요하게 생각합니다.

물론 코드량을 줄이는 것이 성능 향상이랑 항상 직결되진 않습니다. 다만 중복 코드를 줄이면 `모든 코드가 항상 고유한 일을 수행함을 보장`할 수 있으며, 이는 바람직한 설계의 핵심입니다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

컴퓨터는 우리가 시킬 일을 코드를 통해 작성하면 정확히 그대로 반응합니다. 이 처럼 프로그래밍은 컴퓨터와 우리가 대화하는 것과 같기 때문에 "컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야" 합니다.

프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일인거죠. 문제는 우리가 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못하게 됩니다.

코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화(리팩터링)를 줘야합니다. 잘 작동하지만 구조가 이상한 코드가 있다면, 잠시 시간을 내어 리팩터링을 한다던가 말이죠.

이러한 배려는 사실 다른 사람을 위해서 하는 일이 아닙니다. 대부분의 경우 미래의 나 자신을 위한 일이죠. 예를 들어 1년전 과거의 자신이 작성했던 코드로 돌아가보시죠. 우선 저는 과거의 코드가 왜 이렇게 작성되었는지 이해하지 못 했습니다.

즉, 우리는 모든 코드를 기억하지 않을 뿐더러 기억하지 못 합니다. 때문에, 마틴 파울러는 기억할 필요가 있는 것들은 최대한 코드에 담아둘 것을 권장합니다.

### 리팩터링하면 버그를 쉽게 찾을 수 있다.

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말 입니다. 리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 됩니다.

프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해집니다.

### 리팩터링하면 프로그래밍 속도를 높일 수 있다.

지금까지 제시한 장점을 한마디로 정리하면 다음과 같습니다.

> 리팩터링을 하면 코드 개발 속도를 높일 수 있다.

얼핏 그 반대가 아닌가 생각할 수 있습니다. 대부분 리팩터링이 내부 설계와 코드 퀄리티를 높일 수 있다는 점은 대부분 숭은 하지만, 리팩터링을 하는데 시간이 드니 전체 개발 속도가 떨어질까 걱정 할 수도 있습니다.

한 시스템을 오래 개발하는 개발자들과 얘기하다 보면 초기에는 진척이 빨랐지만 현재는 새 기능을 하나 추가하는데 훨씬 오래 걸린다는 말을 많이합니다.

새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이죠.

게다가 기능을 추가하다보면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸리게 됩니다. 

코드베이스는 패치에 패치가 덧붙여지면서 프로그램의 동작을 파악하기가 더욱 어려워지고, 이러한 부담이 점점 늘어나다보면 차라리 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 다다르게 됩니다.

하지만 좋은 설계를 지닌 팀은 기존에 작성한 코드를 최대한 활요할 수 있어서 새 기능을 더 빨리 추가하는게 가능해집니다.

이렇게 차이 나는 원인은 소프트웨어의 내부 품질에 있습니다.

내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 때 모듈화가 잘되어있어서 코드의 작성 포인트를 쉽게 찾을 수 있으며, 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉬워집니다.

결과적으로 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕게되는 것이죠.

마틴 파울러는 이 효과를 설계 지구력 가설 (Design Stamina Hypothesis) 라고 부릅니다. 이는 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다는 것을 의미합니다.

## 2.4 언제 리팩터링해야 할까?

>`3의 법칙`
>
> 돈 로버츠(Don Roberts)가 제시한 가이드
> 
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다면) 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링 한다.
>

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전입니다. 해당 시점의 현 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기 쉬워질 만한 부분을 찾아봅니다.

예를 들면 모든 요구사을 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있을 수 있습니다.

이때, 함수를 복제해서 해당 값만 수정해도 되지만, 그러면 중복 코드가 생깁니다. 이는 이후에 해당 기능을 수정할 일이 생긴다면 수정 포인트가 여러개가 될 가능성을 내포함으로 수정해야합니다.

그래서 이럴 때에는 리팩터링 모자를 쓰고 "함수 매개변수화하기"를 적용합니다. 그러면 나중에 그 함수에 필요한 매개변수를 지정해서 호출하기만 하면 되죠.

버그를 잡을 때에도 마찬가지입니다. 오류를 이르키는 코드가 몇 곳에 복제되어 퍼져있다면 오류 발생 코드를 하나로 합치는 편이 작업하기 편해집니다.

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 코드를 파악해야합니다.

마틴 파울러는 조건부 로직의 구조가 이상하지는 않은지, 함수 이름을 잘못 설정하지 않았는지 등 코드의 의도가 명확하게 들어날 수 있도록 리팩터링할 수 있는지의 관점에서 살펴 보는 것을 추천합니다.

이렇게 관점을 담아 읽어보는 것 만으로 충분히 도움이 되지만 실제로 리팩터링을 하면서 읽는 것도 좋습니다. 

> "리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인 할 수 있다" <br> - 위드 커닝햄(ward cunningham)

이렇게 리팩터링하면 하지 않았을 때보다 더 깊은 수준으로 코드를 이해할 수 있게 됩니다.

### 쓰레기 줍기 리팩터링

코드를 파악하던 주에 일을 비효율적으로 처리하는 모습을 발견할 때가 많습니다. 로직이 쓸데없이 복잡하거나, 매개변후화한 함수 하나면 될 일을 거의 똑같이 함수 여러개로 작성했을 가능성도 있습니다.

이때는 절충이 필요합니다.

원래 하던 작업과 관련 없는 일에 너무 많은 시간을 쓰기 싫지만, 그렇다고 쓰레기가 나뒹굴게 방치하는 것도 일에 방해가 되니 좋지 않습니다.

간단하게 해결 가능하다면 그자리에서 해결하면 되겠지만, 그렇지 않다면 이후를 위해 메모해두고 일을 끝낸 뒤에 처리를 하면 좋습니다. 예를들어 `TODO:` 와 같은 comment를 남기는 것이 대표적이겠죠.

물론 수정하려면 몇 시간이나 걸리고 당장 더 급한 일이 있을 수 있습니다. 그럼에도 캠핑 규칙(항상 처음 왔을 때보다 깔끔하게 정리하고 떠나자.)을 습관처럼 지켜봅시다.

### 계획된 리팩터링과 수시로 하는 리팩터링

앞에서 본 "준비를 위한 리팩터링", "이해를 위한 리팩터링", "쓰레기 줍기 리팩터링"은 모두 기회가 될 때만 진행하게 됩니다.

마틴 파울러는 개발을 들어갈 때 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링을 함께 합니다. 이는 프로그래밍 과정에 자연스럽게 리팩터링을 녹인 것이죠.

리팩터링은 프로그래밍과 구분되는 별개의 활동이 아닙니다.

흔히 리팩터링을 과거에 저지른 실수를 바로잡거나 보기 싫은 코드를 정리하는 작업이라고 오해하기도 합니다. 보기 싫은 코드를 보면 리팩터링 함은 당연하지만 잘 작성된 코드 역시 수 많은 리팩터링을 거쳐야 합니다.

오랫동안 사람들은 소프트웨어 개발이 무언가를 "추가"하는 과정으로 여겨왔습니다. `하지만 뛰어난 개발자는 새 기능을 추가하기 쉽도록 코드를 "수정"하는 것이 그 기능을 가장 빠르게 추가하는 길일 수 있음`을 압니다.

소프트웨어 개발은 끝이 없습니다. 새 기능이 필요할 때마다 소프트웨어는 이를 반영하기 위해 수정됩니다. 이때, 새로운 코드보다 기존 코드의 수정량이 더 큰 경우도 대체로 많죠.

수시로 리팩터링을 해야하지만 계획된 리팩터링도 필요한 경우가 물론 있습니다. 그동한 리팩터링에 소홀 했다면 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있습니다.

### 오래 걸리는 리팩터링

리팩터링은 대부분 몇 분안에 길어야 몇 시간 정도 안에 끝나는 일입니다. 하지만, 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있습니다.

라이브러리를 새로 교체하는 작업일 수 있고, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트를 빼내는 작업일 수 있습니다. 또는 그동안 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업 일 수도 있겠죠.

이런 상황에 처하더라도 팀 전체가 리팩터링에 매달리는 일이 발생하거나 그럴 것 같다면 한번 고민을 해보아야 합니다. "정말 당장의 작업을 중단하고 리팩터링에 매달려야 하는가?" 라고 말이죠.

리팩터링은 코드를 깨트리지 않는다는 장점이 있습니다. 일부를 변경해도 모든 기능이 항상 올바르게 작동해야하죠.

예컨대 라이브러리를 바꾸는 일이라면 기존 것과 새로운 것 모두 포용하는 추상인터페이스를 만들고 기존 코드가 추상 인터페이스를 호출하도록 하면 라이브러리를 훨씬 쉽게 고칠 수 있습니다.


### 코드 리뷰에 리팩터링 활용하기

코드 리뷰를 정기적으로 수행하는 조직도 있습니다. 그렇지 않은 조직이라면 해보는 걸 추천드립니다.

코드 리뷰는 다음과 같은 장점을 가집니다.

- 개발팀 전체에 지식을 전파하기 좋음
- 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수하기 좋음
- 대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람들이 이해하는데 도움을 줌
- 코드를 건강하게 유지하는게 도움을 줌
- 다른 사람의 아이디어를 얻을 수 있음

그러므로 기회가 닿는 대로 코드 리뷰를 하는걸 추천드립니다.

그리고 리팩터링은 다른 이의 코드를 리뷰하는 데도 도움이 됩니다. 리팩터링을 활용하기 전에는 코드를 읽고, 그럭저럭 이해한 뒤 몇가지 개선 사항을 제시했습니다.

마틴 파울러는 새로운 아이디어가 떠오르면 먼저 리팩터링을 통해 쉽게 구현해넣을 수 있는지 살펴보고, 쉽다면 실제로 리팩터링을 진행합니다. 

이 과정을 통해 내가 생각한 아이디어를 적용했을 떄의 모습을 더 명확하게 만들 수 있다합니다. 가끔은 그러지 않았다면 절때 떠올릴 수 없는 한 차원 높은 아이디어를 떠올리기도 한다죠.

결과적으로 리팩터링은 개선안들을 제시하는 데서 그치지 않고, 그 중 상당수를 즉시 구현해볼 수 있게 만듭니다. 이는 코드 리뷰의 결과를 더 구체적으로 도출하는데 도움을 준다는 뜻이죠.

또한, 마틴 파울러는 코드 리뷰를 할 때에는 `코드 작성자가 참여하는` 형태의 리뷰 진행 방식을 추천합니다. 코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있기 때문입니다.

### 리팩터링을 하지 말아야할 때

지금까지의 이야기만 들으면 무조건 리팩터링을 해야한다고 들릴 수도 있지만, 그러면 안되는 경우도 있습니다.

- 외부 API 다루듯 호출해서 사용하는 코드
- 리팩터링을 하는 것보다 처음부터 다시하는게 나은 경우

전자의 경우 내부 동작을 이해해야 할 시점에 리팩터링을 해야 효과를 볼 수 있기 때문입니다.

후자의 경우는 상황이 조금 다릅니다. 판단하기 쉽지 않을 뿐더러 많은 경험이 뒷받침 되어야하기 때문이죠. 대다수 직접 리팩터링을 해보기 전에는 어느것이 쉬운지 확실하게 알기 어렵습니다.
