# Ch02. 리팩터링 원칙

Chapter 1에서 리팩터링이 무엇인지 충분히 감을 잡아보았다.

이를 토대로 이번 장에서는 리팩터링 전반에 적용되는 원칙 몇가지를 설명한다.

## 2.1 리팩터링 정의

> 누군가 "리팩터링하다 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링 한 것이 아니다.

수많은 다른 소프트웨어 개발 용어와 마찬가지로 리팩터링(Refactoring)도 엔지니어들 사이에서 다소 두리뭉실한 의미로 사용됩니다. 하지만, 마틴 파울러는 리팩터링의 의미를 더 구체적으로, 다소 엄격하게 정의함으로써 더 유용하게 사용하고자 합니다.

> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

앞 장에서 본 함수 추출하기와 조건부 로직을 다형성으로 바꾸기 처럼 이름 붙은 리팩터링 기법들이 위 정의에 해당합니다.

> 리팩터링(하다): [동사] 소프트웨어의 걷보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

지금껏 저는 책에서 소개하는 여느 사람들처럼 코드를 정리하는 작업을 모조리 "리팩터링"이라고 표현해왔습니다. 하지만, 마틴 파울러는 위에서 정의한 의미와 같이 `특정한 방식에 따라 코드를 정리하는 것 만이 리팩터링이다`라고 설명하고 있죠.

즉, 이전 챕터에서 했던 것 처럼 리팩터링은 아주 작은 단위로 단계를 나누어 쌓아가는 것임으로 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있습니다.

### 리팩터링 vs 성능 최적화

리팩터링과 성능 최적화는 둘 다 코드를 변경하며 프로그램의 전반적인 기능은 그대로 유지하지만, 그 목적이 상이합니다.

리팩터링의 목적은 `코드를 이해하고 수정하기 쉽게 만드는 것`으로, 프로그램의 성능이 나빠지거나 좋아질 수 있습니다.

반면 성능 최적화는 오로지 속도 개선에만 신경을 씁니다. 때문에 목표 성능에 반드시 도달해야 한다면 코드를 다루기에 더 어렵게 수정할수도 있습니다.

## 2.2 두 개의 모자

켄트 백은 개발의 목적 분리 작업을 두 개의 모자에 비유합니다. 

기능을 추가할 때는 "기능 추가" 모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 합니다. 진척도는 `테스트를 추가해서 통과하는지 확인`하는 방식으로 진행합니다.

또한, 리팩터링을 할 때에는 "리팩터링" 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념합니다. 이때는 앞 과정에서 놓친 테스트 케이스를 발견한게 아닌 이상 `테스트를 추가하지 않습니다.` 

이러한 각각의 작업시간은 10분 미만으로 짧을 수 있습니다. 그럼에도 마틴 파울러는 항상 내가 쓰고 있는 모자가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인지할 것을 권장합니다.

## 2.3 리팩터링하는 이유

리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 아니지만, 코드를 건강한 상태로 유지하는 데 도움을 주는 약입니다.

### 리팩터링하면 소프트웨어 설계가 좋아진다.

리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 섞기 쉽습니다. 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉬워지며, 그러면 코드만으론 설계를 이해하기 어려워집니다. 

이런 방식으로 우리의 코드와 설계는 부패되기 시작합니다. 이를 방지하기 위해 리팩터링을 해야하죠.

같은 일을 하더라도 설계가 나쁘면 코드가 길어집니다. 사실상 같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문인데요. 때문에 우리는 중복 코드를 제거하는 걸 중요하게 생각합니다.

물론 코드량을 줄이는 것이 성능 향상이랑 항상 직결되진 않습니다. 다만 중복 코드를 줄이면 `모든 코드가 항상 고유한 일을 수행함을 보장`할 수 있으며, 이는 바람직한 설계의 핵심입니다.

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다.

컴퓨터는 우리가 시킬 일을 코드를 통해 작성하면 정확히 그대로 반응합니다. 이 처럼 프로그래밍은 컴퓨터와 우리가 대화하는 것과 같기 때문에 "컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야" 합니다.

프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일인거죠. 문제는 우리가 프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못하게 됩니다.

코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화(리팩터링)를 줘야합니다. 잘 작동하지만 구조가 이상한 코드가 있다면, 잠시 시간을 내어 리팩터링을 한다던가 말이죠.

이러한 배려는 사실 다른 사람을 위해서 하는 일이 아닙니다. 대부분의 경우 미래의 나 자신을 위한 일이죠. 예를 들어 1년전 과거의 자신이 작성했던 코드로 돌아가보시죠. 우선 저는 과거의 코드가 왜 이렇게 작성되었는지 이해하지 못 했습니다.

즉, 우리는 모든 코드를 기억하지 않을 뿐더러 기억하지 못 합니다. 때문에, 마틴 파울러는 기억할 필요가 있는 것들은 최대한 코드에 담아둘 것을 권장합니다.

### 리팩터링하면 버그를 쉽게 찾을 수 있다.

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말 입니다. 리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 됩니다.

프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해집니다.

### 리팩터링하면 프로그래밍 속도를 높일 수 있다.

지금까지 제시한 장점을 한마디로 정리하면 다음과 같습니다.

> 리팩터링을 하면 코드 개발 속도를 높일 수 있다.

얼핏 그 반대가 아닌가 생각할 수 있습니다. 대부분 리팩터링이 내부 설계와 코드 퀄리티를 높일 수 있다는 점은 대부분 숭은 하지만, 리팩터링을 하는데 시간이 드니 전체 개발 속도가 떨어질까 걱정 할 수도 있습니다.

한 시스템을 오래 개발하는 개발자들과 얘기하다 보면 초기에는 진척이 빨랐지만 현재는 새 기능을 하나 추가하는데 훨씬 오래 걸린다는 말을 많이합니다.

새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다는 것이죠.

게다가 기능을 추가하다보면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸리게 됩니다. 

코드베이스는 패치에 패치가 덧붙여지면서 프로그램의 동작을 파악하기가 더욱 어려워지고, 이러한 부담이 점점 늘어나다보면 차라리 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 다다르게 됩니다.

하지만 좋은 설계를 지닌 팀은 기존에 작성한 코드를 최대한 활요할 수 있어서 새 기능을 더 빨리 추가하는게 가능해집니다.

이렇게 차이 나는 원인은 소프트웨어의 내부 품질에 있습니다.

내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 때 모듈화가 잘되어있어서 코드의 작성 포인트를 쉽게 찾을 수 있으며, 코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉬워집니다.

결과적으로 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕게되는 것이죠.

마틴 파울러는 이 효과를 설계 지구력 가설 (Design Stamina Hypothesis) 라고 부릅니다. 이는 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다는 것을 의미합니다.