# Ch03. 코드에서 나는 악취

리팩터링을 `언제 시작하고 언제 그만할지`를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요합니다.

하지만 여기에는 딜레마가 있습니다. 인스턴스 변수를 삭제하거나 상속 계층을 만드는 방법을 설명하는 것은 쉬운 일에 속하죠. 하지만 이런 일들을 `언제` 해야 하느냐에 대한 것은 명확하게 정리된 것이 없습니다.

때문에 책에서도 리팩터링은 이때해야한다! 라는 명확한 기준을 제시하지 않습니다. 대신 마틴 파울러와 캔트 백은 이번 챕터를 통해 코드에서 나는 `악취`들을 소개합니다.

여기서 악취라는 것은 리팩터링의 시작과 종료 기준이 아닙니다. 다만 마치 갓난아기의 기저귀에서 나는 냄새에 따라 기저귀를 갈아줄 시점을 판단하는 것처럼, `악취의 종류`와 `악취를 리팩터링하면 해결할 수 있는 문제의 징후`를 제시하는 것이죠.

> 이 뒤로는 책에 나와있는 악취들을 한 번에 머리에 넣기 힘들어 제 나름대로 분류를 나누어 설명할 것이기 때문에 책과는 순서가 다를 수 있습니다.


## 거대해진 코드에서 나는 냄새

이 악취들은 불필요하게 불 필요하게 부풀어 오른 코드, 메서드, 클래스 등에서 나타납니다. 일반적으로 바로 나타나는 악취들이 아니라, 프로그램을 발전하면서 시간이 지남에 따라 스멀스멀 피어오르는 악취들이죠.

### 3.1 기이한 이름
> Mysterious Name <br>
> [함수 선언 바꾸기](), [변수 이름 바꾸기](), [필드 이름 바꾸기]()

추리 소설이라면 무슨 일이 전개되는지 궁금증을 자아낼수록 좋겠지만, 코드에서는 아닙니다. 코드를 명료하게 표한하는 데 가장 중요한 요소 중 하나는 바로 `이름`입니다. 

그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 해야합니다.

책에서는 더 나아가 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니라, 설계의 문제를 파악할 수 있는 열쇠로도 설명합니다.

만약 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다는 것이죠.

### 3.3 긴 함수
> Long Function

### 3.4 긴 매개변수 목록
> Long Parameter List


### 3.5 전역 데이터
> Global Data

전역 데이터를 주의해야 한다는 것은 소프트웨어 개발을 처음 배우기 시작할 때부터 자주 들으셨을 겁니다.

전역 데이터는 악취 중 가장 독한 악취 중 하나입니다. 코드 베이스 어디에서나 변경이 가능하여 마치 유령 같은 원격작용처럼, 버그는 계속 발생하는데 이 변경 시점을 추적하기 힘들기 때문입니다.

전역 데이터의 가장 대표적인 형태는 `전역 변수`이지만 `클래스 변수`와 `싱글톤`에서도 같은 문제가 발생합니다.

이 문제를 해결하기 위해서는 [변수를 캡슐화]() 하여 `접근 포인트`를 제어하거나, 전역 데이터를 `불변 데이터`로 변경하면 됩니다.

### 3.10 데이터 뭉치
> Data Clumps

### 3.11 기본형 집착
> Primitive Obsession


### 3.20 거대한 클래스
> Large Class

## 객체 지향의 냄새

이 악취들은 객체 지향 프로그래밍 원칙을 불완전하거나 잘못 적용한 결과입니다.

### 3.12 반복되는 switch 문
> Repeated Switches 

### 3.16 임시 필드
> Temporary Field

### 3.21 서로 다른 인터페이스의 대안 클래스들
> Alternative Classes with Different Interfaces

### 3.23 상속 포기
> Refused Bequest

## 변경을 방해하는 냄새

이 악취들이 느껴진다면 코드의 한 부분을 변경해야 할 때, 다른 여러 곳에서도 변경을 해야합니다. 그 결과 프로그램 개발은 훨씬 더 복잡하고 비용이 많이 들게 되죠.

### 3.6  가변 데이터
> Mutable Data 

### 3.7 뒤엉킨 변경
> Divergent Change

### 3.8 산탄총 수술
> Shotgun Surgery

## 불필요한 요소의 냄새

말 그대로 코드에 숨어있는 불필요한 요소들이 내는 악취입니다. 이를 제거하면 코드가 더 깔끔하고 효율적이며 이해하기 쉬워집니다.

### 3.2 중복 코드
> Duplicate Code

### 3.13 반복문
> Loops

### 3.14 성의 없는 요소
> Lazy Element

### 3.15 추측성 일반화
> Speculative Generality

### 3.22 데이터 클래스
> Data class

### 3.24 주석
> Comments

## 결합도의 냄새

코드에 이런 악취가 있다면 클래스 간의 지나치게 강한 결합을 초래하거나, 결합이 과도한 위임으로 대체되었을 가능성이 있습니다.

### 3.9 기능 편애
> Feature Envy

### 3.17 메시지 체인
> Message Chains

### 3.18 중개자
> Middle Man

### 3.19 내부자 거래
> insider Trading