# Ch03. 코드에서 나는 악취

리팩터링을 `언제 시작하고 언제 그만할지`를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요합니다.

하지만 여기에는 딜레마가 있습니다. 인스턴스 변수를 삭제하거나 상속 계층을 만드는 방법을 설명하는 것은 쉬운 일에 속하죠. 하지만 이런 일들을 `언제` 해야 하느냐에 대한 것은 명확하게 정리된 것이 없습니다.

때문에 책에서도 리팩터링은 이때해야한다! 라는 명확한 기준을 제시하지 않습니다. 대신 마틴 파울러와 캔트 백은 이번 챕터를 통해 코드에서 나는 `악취`들을 소개합니다.

여기서 악취라는 것은 리팩터링의 시작과 종료 기준이 아닙니다. 다만 마치 갓난아기의 기저귀에서 나는 냄새에 따라 기저귀를 갈아줄 시점을 판단하는 것처럼, `악취의 종류`와 `악취를 리팩터링하면 해결할 수 있는 문제의 징후`를 제시하는 것이죠.

> 이 뒤로는 책에 나와있는 악취들을 한 번에 머리에 넣기 힘들어 제 나름대로 분류를 나누어 설명할 것이기 때문에 책과는 순서가 다를 수 있습니다.

## 거대해진 코드에서 나는 냄새

이 악취들은 불필요하게 불 필요하게 부풀어 오른 코드, 메서드, 클래스 등에서 나타납니다. 일반적으로 바로 나타나는 악취들이 아니라, 프로그램을 발전하면서 시간이 지남에 따라 스멀스멀 피어오르는 악취들이죠.

### 3.1 기이한 이름
> Mysterious Name <br>
> [함수 선언 바꾸기](), [변수 이름 바꾸기](), [필드 이름 바꾸기]()

추리 소설이라면 무슨 일이 전개되는지 궁금증을 자아낼수록 좋겠지만, 코드에서는 아닙니다. 코드를 명료하게 표한하는 데 가장 중요한 요소 중 하나는 바로 `이름`입니다.

그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 해야합니다.

책에서는 더 나아가 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니라, 설계의 문제를 파악할 수 있는 열쇠로도 설명합니다.

만약 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다는 것이죠.

### 3.3 긴 함수
> Long Function

오랜 기간 잘 활용되는 함수들은 대체로 길이가 짧습니다. 이런 함수들은 코드가 끝없이 위임하는 방식으로 작성되어 있습니다. 즉, 짦은 함수로 만든다는 건 하나의 긴 함수처럼 모든 계산을 하는 것이 아니라 짧은 함수 여러개를 호출하는 구조를 말하게 되는 것이죠.

이런 구조는 코드를 이해하고, 공유하고 선택하기 쉬워진다는 장점을 가집니다.

물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 부담이 될 수 있습니다. 때문에 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름을 짓는 것 입니다.

함수 이름을 잘 지어두면 본문의 내용을 읽을 이유가 없기 때문이죠.

그러기 위해서는 훨씬 적극적으로 함수를 쪼개야합니다. 예를 들어 주석이 필요한 부분이 있다면 함수로 만드는 것이죠.

그러면 그 함수 본문에는 주석으로 설명하려던 코드가 담기고, 함수의 이름은 동작 방식이 아닌 함수의 `의도`를 담게 됩니다.

이렇게 우리는 점점 함수의 목적(의도)과 구현 코드의 괴리를 점점 줄여갈 수 있게 됩니다. 즉, `무엇을 하는지`를 코드가 잘 설명해주지 못할수록 함수로 만들어 나가는 것이죠.

단, 이런 작업은 여러 방법으로 진행될 수 있습니다.

[ 일반적인 상황 ]

일반적으론 [함수 추출하기]()을 사용하는 것 만으로 충분합니다.

[ 함수에 매개변수와 임시 변수가 너무 많은 경우 ]

이런 상황이라면 추출 작업을 하기가 어렵습니다. 이런 상황에서 바로 추출을 해버린다면, 추출된 함수에도 매개변수가 많아져 오히려 코드의 `의도`를 알기 어려워지죠.

때문에 추출하기에 앞서 먼저 `임시변수`에는 [임시변수를 질의함수로 바꾸기]()를 그리고 `매개변수`에는 [매개변수 객체 만들기]()와 [객체 통째로 넘기기]()를 통해 변수의 수를 줄여야합니다.

만약 그럼에도 변수가 너무 많다면 [함수를 명령으로 바꾸기]()를 적용해야하는 상황입니다.

[ 조건문과 Switch문 ]

조건문은 간단하게 [조건문 분해하기]()로 대응이 가능합니다.

거대한 Switch 문은 구성 case문마다 [함수 추출하기]()를 적용해서 각 case의 본문을 바꾸거나, 같은 조건을 기준으로 나뉘는 Switch문이 여러개라면 [조건문을 다형성으로 바꾸기]()를 적용할 수 있습니다.

[ 반복문 ]

반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만들 수 있습니다. 만약 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면
성격이 다른 작업이 섞여있을 가능성이 있습니다. 이땐 [반복문 쪼개기]()를 적용해서 작업을 분리합니다.

### 3.4 긴 매개변수 목록
> Long Parameter List

우리는 함수에 필요한 데이터를 함수 파라미터로 넣으라고 배웠습니다. 그래야 전역 데이터의 사용을 줄일 수 있기 때문이죠. 하지만 매개변수의 목록이 길어지면 그 자체로 이해하기 어려워집니다.

매개변수의 수를 줄이는 방법은 상황별로 다릅니다.

- 다른 매개변수에서 얻을 수 있는 값이 있다면, [매개 변수를 질의 함수로 바꾸기]()를
- 사용 중인 데이터 구조에서 값을 뽑아 넘기는 구조라면, [객체 통째로 넘기기]()를
- 항상 함께 전달되는 매개변수들이 있다면, [변수 객체로 만들기]()를
- 매개변수가 함수의 동작을 제어하는 플래그라면, [플래그 인수 제거하기]()를
- 여러 함수에서 공통적으로 사용하는 파라미터들이 있다면, [여러 함수를 클래스로 묶기]()를

위와 같이 상황별로 다른 기법을 적용할 수 있습니다.

### 3.5 전역 데이터
> Global Data

전역 데이터를 주의해야 한다는 것은 소프트웨어 개발을 처음 배우기 시작할 때부터 자주 들으셨을 겁니다.

전역 데이터는 악취 중 가장 독한 악취 중 하나입니다. 코드 베이스 어디에서나 변경이 가능하여 마치 유령 같은 원격작용처럼, 버그는 계속 발생하는데 이 변경 시점을 추적하기 힘들기 때문입니다.

전역 데이터의 가장 대표적인 형태는 `전역 변수`이지만 `클래스 변수`와 `싱글톤`에서도 같은 문제가 발생합니다.

이 문제를 해결하기 위해서는 [변수를 캡슐화]() 하여 `접근 포인트`를 제어하거나, 전역 데이터를 `불변 데이터`로 변경하면 됩니다.

### 3.10 데이터 뭉치
> Data Clumps

데이터 항목들은 어린아이 같아서 서로 어울려 놀길 좋아합니다. 그래서 서너 개가 여러 곳에서 항상 함께 뭉처 다니는 모습을 흔히 목격할 수 있죠.

특정 클래스의 필드끼리 다니거나, 한 메소드에서 파라미터로 같이 다니거나 다양한 모습으로 발견이 됩니다.

이런 데이터 뭉치들은 보금자리를 만들어 주어야합니다.

- 클래스의 특정 필드끼리 몰려다닌다면, [클래스 추출하기 기법]()으로
- 메소드의 파라미터끼리 몰려다닌다면, [매개변수 객체 만들기 기법]()이나 [객체 통째로 넘기기]()로

데이터 뭉치를 분리해줍니다.

데이터 뭉치인지 확인하는 방법은 값을 하나 지워본다고 가정하는 것입니다. 만약 나머지 데이터만으로는 의미가 없다면 객체로 환생하고 싶은 데이터라는 뜻입니다.

### 3.11 기본형 집착
> Primitive Obsession

대부분의 프로그래밍 언어에서는 기본형 타입을 지원합니다. 정수, 부동소수점 수, 문자열과 같은 기본형을 말이죠.

그래서인지 프로그래머들은 이런 기본형들을 그냥 사용는걸 선호하며 문제를 해결하기 위해 클래스로 만드는걸 꺼리는 경향이 있습니다. (화폐, 좌표, 전화번호 등)

이 냄새는 문자열을 다루는 코드에서 특히 흔하게 맡을 수 있습니다. 예를 들어 전화번호를 단순히 문자열로 바라보는 경우가 있죠.

전화번호라는 객체가 가질 수 있는 기능이 많음에도 말입니다.

그래서 이런 기본형을 객체로 바꿔주는 작업을 해야합니다.

- 단순한 기본형만 존제하는 코드라면, [기본형을 객체로 바꾸기]()를 적용
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드라면, [타입 코드를 서브클래스로 바꾸기]()와 [조건부 로직을 다형성으로 바꾸기]()를 차례로 적용
- 자주 몰려다니는 기본형 그룹이 있다면, [클래스 추출하기]()와 [매개변수 객체 만들기]()를 적용

이런 방식으로 기본형만 존재하는 구석기 동굴을 의미 있는 자료형들이 사는 문명사회로 탈바꿈 할 수 있습니다.

### 3.20 거대한 클래스
> Large Class

[ 필드가 너무 많은 클래스 ]

한 클래스가 너무 많은 일을 하려다 보면 당연하게도 필드의 수가 늘어나게 됩니다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉬워지죠.

일반적으론 [클래스 추출하기]()로 필드들 일부를 따로 묶는게 좋습니다. 주로 접두어나 접미어가 같은 필드들이 같이 추출 할 후보군이됩니다.

만약 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면 [슈퍼클래스 추출하기]()나 [타입 코드를 서브클래스로 바꾸기]()를 적용하는 편이 더 쉽습니다.

[ 코드량이 너무 많은 클래스 ]

필드가 많은 클래스처럼 코드량이 너무 많은 경우에도 중복 코드와 혼동을 이르킬 여지가 있습니다. 가장 간단한 해법은 자체적으로 클래스 내부의 중복을 제거하는 것 입니다.

## 좋지 않은 객체 지향의 냄새

이 악취들은 객체 지향 프로그래밍 원칙을 불완전하거나 잘못 적용한 결과입니다.

### 3.12 반복되는 switch 문
> Repeated Switches

1990년대 후반과 비교해서 지금은 다형성이 널리 자리 잡아서 단순히 switch문을 썼다고 해서 자동으로 검토 대상은 되지 않습니다. 게다가 분기 조건에 몇가지 기본형만 쓸 수 있던 예전과 달리, 문자열 등의 더 복잡한 타입까지 지원하는 발전된 switch문을 제공하는 언어도 많아졌죠.

그러니 이제는 똑같은 조건부 로직이 여러곳에서 반복해 등장하는 코드에 집중해봅시다. 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 수정해야하기 때문입니다.

이럴 때 다형성은 switch문의 내뿜는 사악한 기운을 제압하여 코드베이스를 최신으로 바꿔주는 세련된 무기로 작용합니다.

### 3.16 임시 필드
> Temporary Field

간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있습니다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는게 보통이라, 이렇게 임시 필드를 갖도록하면 코드를 이해하기 어려워집니다.

이렇게 덩그러니 떨어져있는 필드를 발견하면 다음과 같은 순서로 제거해봅시다.

1. [클래스 추출하기]()로 제 살 곳을 찾아준다.
2. [함수 옮기기]()로 임시 필드와 관련된 코드를 새 클래스에 옮겨준다.
3. 임시 필드들이 유효한지 확인 후 동작하는 조건부 로직이 있다면, [특이 케이스 추가하기]()를 통해 해결한다.

### 3.21 서로 다른 인터페이스의 대안 클래스들
> Alternative Classes with Different Interfaces

클래스를 사용할 때의 강점은 필요에 따라 다른 클래스로 교체할 수 있다는 것입니다. 단, 그러기 위해서는 인터페이스가 같아야하죠.

따라서 [함수 선언 바꾸기]()를 통해 메서드 시그니처를 일치시킵니다. 이것으로 부족하다면, [함수 옮기기]()를 통해 인터페이스가 같아질 때까지 필요한 동작들을 클래스 내부에 숨깁니다. 그러다 중복 코드가 생기면 [슈퍼클래스 호출하기]()를 적용해봐도 좋겠죠.

### 3.23 상속 포기
> Refused Bequest

서브 클래스는 부모로부터 메소드와 데이터를 물려받습니다. 그치만 일부만 필요하고 일부는 필요없다면 어떻게 해야할까요?

예전에는 이를 설계를 잘못했기 때문에 생긴 문제라고 생각했습니다. 때문에 같은 계층에 서브 클래스를 하나 만들고 [메서드 내리기]()와 [필드 내리기]()를 통해 부모에는 진짜 공통적인 부분만 남기려고 노력했다하죠.

대게 공통적인 속성을 남겨놔서 재활용하는 기법은 유용하지만 지금은 해당 방식을 무조건 권하지 않습니다.

상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 납니다. 구현을 따르지 않는 것은 이해할 수 있으나 인터페이스를 따르지 않는다는 것은 문제가 생길 수 있죠.

이럴 때는 [서브클래스를 위임으로 바꾸기]() 또는 [슈퍼클래스를 위임으로 바꾸기]()를 활용해서 아예 상속에서 벗어나봅시다.

## 변경을 방해하는 냄새

이 악취들이 느껴진다면 코드의 한 부분을 변경해야 할 때, 다른 여러 곳에서도 변경을 해야합니다. 그 결과 프로그램 개발은 훨씬 더 복잡하고 비용이 많이 들게 되죠.

### 3.6 가변 데이터
> Mutable Data

데이터를 변경했더니 예상치 못한 결과가 발생하는 경우가 있습니다. 이런 문제는 드물지만, 한 번 발생하면 원인을 찾기 매우 어려울 수 있습니다.

이러한 이유로 함수형 프로그래밍에서는 데이터를 변경하지 않거나, 변경이 필요할 경우 원본 데이터의 복제본을 만들어 사용합니다. 하지만 함수형 프로그래밍을 사용하는 경우는 상대적으로 적고, 대부분의 언어에서는 변수 변경을 지원합니다.

그렇다고 해서 불변성이 주는 장점을 포기할 필요는 없습니다. 가변 데이터로 인해 발생할 수 있는 문제를 방지하는 다양한 방법이 있습니다.

- **데이터 변경을 특정 방식으로만 허용하고 싶다면**, [변수 캡슐화하기]()를 활용하여 정해진 함수만을 통해 접근하도록 제한합니다.
- **여러 가지 용도로 사용되는 변수가 있다면**, [변수 쪼개기]()를 통해 변수의 역할을 분리하여 필요한 값만 갱신하도록 만듭니다.
- **갱신 로직이 코드의 다른 부분과 뒤섞여 있다면**, [함수 추출하기]()와 [문장 슬라이스 하기]()를 적용하여 갱신 로직을 독립적으로 관리합니다.
- **API에서 데이터 변경을 최소화하고 싶다면**, [질의 함수와 변경 함수 분리하기]()를 통해 부작용이 있는 코드 호출을 제한합니다.
- **불필요한 변수 변경을 원천 차단하고 싶다면**, [세터 제거하기]()를 적용하여 값 변경이 발생하지 않도록 합니다.
- **파생 변수가 많아 관리가 어렵다면**, [파생 변수를 질의 함수로 바꾸기]()를 사용하여 계산된 값으로 대체합니다.
- **변수의 유효 범위가 넓어 관리가 어렵다면**, [여러 함수를 클래스로 묶기]() 또는 [여러 함수를 변환 함수로 묶기]()를 활용하여 변수 갱신을 특정 영역 내에서만 수행하도록 제한합니다.
- **구조체 내부 필드를 직접 수정하는 경우가 많다면**, [참조를 값으로 바꾸기]()를 통해 구조체 전체를 교체하는 방식으로 변경을 관리합니다.

### 3.7 뒤엉킨 변경
> Divergent Change

우리는 소프트웨어를 변경하기 쉬운 구조로 바꾸기 위해 노력합니다. 이는 변경 포인트를 한 군데로 두고 고립시킨다는 말입니다.

이렇게 할 수 없다면 [뒤엉킨 변경](#37-뒤엉킨-변경)과 [산탄총 수술](#38-산탄총-수술) 중 하나의 악취가 풍기는 코드이기 때문입니다.

뒤엉킨 변경은 SRP가 제대로 지켜지지 않을 때 나타납니다. 즉, 하나의 기능을 지원하기 위해 고쳐야하는 부분이 여러 군데에 있다면 이는 뒤엉킨 변경이 발생한 것입니다.

뒤엉킨 변경은 코드를 맥락별로 분리함으로 해결할 수 있습니다.

- **순차적으로 실행되는 게 자연스러운 맥락이라면**, [단계 쪼개기]()를 통해 순차적인 맥락에 맞게 구조를 분리합니다.
- **전체 처리 과정에서 각기 다른 맥락의 함수를 호출하고 있다면**, 같은 맥락을 가진 함수들을 [함수 옮기기]() 기법을 통해 모아주면 좋습니다.
- **여러 맥락을 드나드는 함수가 있다면**, [함수 추출하기]()를 통해 이를 분리합니다.
- **모듈이 클래스 단위라면**, [클래스 추출하기]()으로 맥락별로 분리합니다.

### 3.8 산탄총 수술
> Shotgun Surgery

## 불필요한 요소의 냄새

말 그대로 코드에 숨어있는 불필요한 요소들이 내는 악취입니다. 이를 제거하면 코드가 더 깔끔하고 효율적이며 이해하기 쉬워집니다.

### 3.2 중복 코드
> Duplicate Code

### 3.13 반복문
> Loops

### 3.14 성의 없는 요소
> Lazy Element

### 3.15 추측성 일반화
> Speculative Generality

### 3.22 데이터 클래스
> Data class

### 3.24 주석
> Comments

## 결합도의 냄새

코드에 이런 악취가 있다면 클래스 간의 지나치게 강한 결합을 초래하거나, 결합이 과도한 위임으로 대체되었을 가능성이 있습니다.

### 3.9 기능 편애
> Feature Envy

### 3.17 메시지 체인
> Message Chains

### 3.18 중개자
> Middle Man

### 3.19 내부자 거래
> insider Trading