# Ch03. 코드에서 나는 악취

리팩터링을 `언제 시작하고 언제 그만할지`를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요합니다.

하지만 여기에는 딜레마가 있습니다. 인스턴스 변수를 삭제하거나 상속 계층을 만드는 방법을 설명하는 것은 쉬운 일에 속하죠. 하지만 이런 일들을 `언제` 해야 하느냐에 대한 것은 명확하게 정리된 것이 없습니다.

때문에 책에서도 리팩터링은 이때해야한다! 라는 명확한 기준을 제시하지 않습니다. 대신 마틴 파울러와 캔트 백은 이번 챕터를 통해 코드에서 나는 `악취`들을 소개합니다.

여기서 악취라는 것은 리팩터링의 시작과 종료 기준이 아닙니다. 다만 마치 갓난아기의 기저귀에서 나는 냄새에 따라 기저귀를 갈아줄 시점을 판단하는 것처럼, `악취의 종류`와 `악취를 리팩터링하면 해결할 수 있는 문제의 징후`를 제시하는 것이죠.

> 이 뒤로는 책에 나와있는 악취들을 한 번에 머리에 넣기 힘들어 제 나름대로 분류를 나누어 설명할 것이기 때문에 책과는 순서가 다를 수 있습니다.

## 거대해진 코드에서 나는 냄새

이 악취들은 불필요하게 불 필요하게 부풀어 오른 코드, 메서드, 클래스 등에서 나타납니다. 일반적으로 바로 나타나는 악취들이 아니라, 프로그램을 발전하면서 시간이 지남에 따라 스멀스멀 피어오르는 악취들이죠.

### 3.1 기이한 이름
> Mysterious Name <br>
> [함수 선언 바꾸기](), [변수 이름 바꾸기](), [필드 이름 바꾸기]()

추리 소설이라면 무슨 일이 전개되는지 궁금증을 자아낼수록 좋겠지만, 코드에서는 아닙니다. 코드를 명료하게 표한하는 데 가장 중요한 요소 중 하나는 바로 `이름`입니다.

그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 해야합니다.

책에서는 더 나아가 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니라, 설계의 문제를 파악할 수 있는 열쇠로도 설명합니다.

만약 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다는 것이죠.

### 3.3 긴 함수
> Long Function

오랜 기간 잘 활용되는 함수들은 대체로 길이가 짧습니다. 이런 함수들은 코드가 끝없이 위임하는 방식으로 작성되어 있습니다. 즉, 짦은 함수로 만든다는 건 하나의 긴 함수처럼 모든 계산을 하는 것이 아니라 짧은 함수 여러개를 호출하는 구조를 말하게 되는 것이죠.

이런 구조는 코드를 이해하고, 공유하고 선택하기 쉬워진다는 장점을 가집니다.

물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 부담이 될 수 있습니다. 때문에 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름을 짓는 것 입니다.

함수 이름을 잘 지어두면 본문의 내용을 읽을 이유가 없기 때문이죠.

그러기 위해서는 훨씬 적극적으로 함수를 쪼개야합니다. 예를 들어 주석이 필요한 부분이 있다면 함수로 만드는 것이죠.

그러면 그 함수 본문에는 주석으로 설명하려던 코드가 담기고, 함수의 이름은 동작 방식이 아닌 함수의 `의도`를 담게 됩니다.

이렇게 우리는 점점 함수의 목적(의도)과 구현 코드의 괴리를 점점 줄여갈 수 있게 됩니다. 즉, `무엇을 하는지`를 코드가 잘 설명해주지 못할수록 함수로 만들어 나가는 것이죠.

단, 이런 작업은 여러 방법으로 진행될 수 있습니다.

[ 일반적인 상황 ]

일반적으론 [함수 추출하기]()을 사용하는 것 만으로 충분합니다.

[ 함수에 매개변수와 임시 변수가 너무 많은 경우 ]

이런 상황이라면 추출 작업을 하기가 어렵습니다. 이런 상황에서 바로 추출을 해버린다면, 추출된 함수에도 매개변수가 많아져 오히려 코드의 `의도`를 알기 어려워지죠.

때문에 추출하기에 앞서 먼저 `임시변수`에는 [임시변수를 질의함수로 바꾸기]()를 그리고 `매개변수`에는 [매개변수 객체 만들기]()와 [객체 통째로 넘기기]()를 통해 변수의 수를 줄여야합니다.

만약 그럼에도 변수가 너무 많다면 [함수를 명령으로 바꾸기]()를 적용해야하는 상황입니다.

[ 조건문과 Switch문 ]

조건문은 간단하게 [조건문 분해하기]()로 대응이 가능합니다.

거대한 Switch 문은 구성 case문마다 [함수 추출하기]()를 적용해서 각 case의 본문을 바꾸거나, 같은 조건을 기준으로 나뉘는 Switch문이 여러개라면 [조건문을 다형성으로 바꾸기]()를 적용할 수 있습니다.

[ 반복문 ]

반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만들 수 있습니다. 만약 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면
성격이 다른 작업이 섞여있을 가능성이 있습니다. 이땐 [반복문 쪼개기]()를 적용해서 작업을 분리합니다.

### 3.4 긴 매개변수 목록
> Long Parameter List

우리는 함수에 필요한 데이터를 함수 파라미터로 넣으라고 배웠습니다. 그래야 전역 데이터의 사용을 줄일 수 있기 때문이죠. 하지만 매개변수의 목록이 길어지면 그 자체로 이해하기 어려워집니다.

매개변수의 수를 줄이는 방법은 상황별로 다릅니다.

- 다른 매개변수에서 얻을 수 있는 값이 있다면, [매개 변수를 질의 함수로 바꾸기]()를
- 사용 중인 데이터 구조에서 값을 뽑아 넘기는 구조라면, [객체 통째로 넘기기]()를
- 항상 함께 전달되는 매개변수들이 있다면, [변수 객체로 만들기]()를
- 매개변수가 함수의 동작을 제어하는 플래그라면, [플래그 인수 제거하기]()를
- 여러 함수에서 공통적으로 사용하는 파라미터들이 있다면, [여러 함수를 클래스로 묶기]()를

위와 같이 상황별로 다른 기법을 적용할 수 있습니다.

### 3.5 전역 데이터
> Global Data

전역 데이터를 주의해야 한다는 것은 소프트웨어 개발을 처음 배우기 시작할 때부터 자주 들으셨을 겁니다.

전역 데이터는 악취 중 가장 독한 악취 중 하나입니다. 코드 베이스 어디에서나 변경이 가능하여 마치 유령 같은 원격작용처럼, 버그는 계속 발생하는데 이 변경 시점을 추적하기 힘들기 때문입니다.

전역 데이터의 가장 대표적인 형태는 `전역 변수`이지만 `클래스 변수`와 `싱글톤`에서도 같은 문제가 발생합니다.

이 문제를 해결하기 위해서는 [변수를 캡슐화]() 하여 `접근 포인트`를 제어하거나, 전역 데이터를 `불변 데이터`로 변경하면 됩니다.

### 3.10 데이터 뭉치
> Data Clumps

데이터 항목들은 어린아이 같아서 서로 어울려 놀길 좋아합니다. 그래서 서너 개가 여러 곳에서 항상 함께 뭉처 다니는 모습을 흔히 목격할 수 있죠.

특정 클래스의 필드끼리 다니거나, 한 메소드에서 파라미터로 같이 다니거나 다양한 모습으로 발견이 됩니다.

이런 데이터 뭉치들은 보금자리를 만들어 주어야합니다.

- 클래스의 특정 필드끼리 몰려다닌다면, [클래스 추출하기 기법]()으로
- 메소드의 파라미터끼리 몰려다닌다면, [매개변수 객체 만들기 기법]()이나 [객체 통째로 넘기기]()로

데이터 뭉치를 분리해줍니다.

데이터 뭉치인지 확인하는 방법은 값을 하나 지워본다고 가정하는 것입니다. 만약 나머지 데이터만으로는 의미가 없다면 객체로 환생하고 싶은 데이터라는 뜻입니다.

### 3.11 기본형 집착
> Primitive Obsession

대부분의 프로그래밍 언어에서는 기본형 타입을 지원합니다. 정수, 부동소수점 수, 문자열과 같은 기본형을 말이죠.

그래서인지 프로그래머들은 이런 기본형들을 그냥 사용는걸 선호하며 문제를 해결하기 위해 클래스로 만드는걸 꺼리는 경향이 있습니다. (화폐, 좌표, 전화번호 등)

이 냄새는 문자열을 다루는 코드에서 특히 흔하게 맡을 수 있습니다. 예를 들어 전화번호를 단순히 문자열로 바라보는 경우가 있죠.

전화번호라는 객체가 가질 수 있는 기능이 많음에도 말입니다.

그래서 이런 기본형을 객체로 바꿔주는 작업을 해야합니다.

- 단순한 기본형만 존제하는 코드라면, [기본형을 객체로 바꾸기]()를 적용
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드라면, [타입 코드를 서브클래스로 바꾸기]()와 [조건부 로직을 다형성으로 바꾸기]()를 차례로 적용
- 자주 몰려다니는 기본형 그룹이 있다면, [클래스 추출하기]()와 [매개변수 객체 만들기]()를 적용

이런 방식으로 기본형만 존재하는 구석기 동굴을 의미 있는 자료형들이 사는 문명사회로 탈바꿈 할 수 있습니다.

### 3.20 거대한 클래스
> Large Class

[ 필드가 너무 많은 클래스 ]

한 클래스가 너무 많은 일을 하려다 보면 당연하게도 필드의 수가 늘어나게 됩니다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉬워지죠.

일반적으론 [클래스 추출하기]()로 필드들 일부를 따로 묶는게 좋습니다. 주로 접두어나 접미어가 같은 필드들이 같이 추출 할 후보군이됩니다.

만약 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면 [슈퍼클래스 추출하기]()나 [타입 코드를 서브클래스로 바꾸기]()를 적용하는 편이 더 쉽습니다.

[ 코드량이 너무 많은 클래스 ]

필드가 많은 클래스처럼 코드량이 너무 많은 경우에도 중복 코드와 혼동을 이르킬 여지가 있습니다. 가장 간단한 해법은 자체적으로 클래스 내부의 중복을 제거하는 것 입니다.

## 좋지 않은 객체 지향의 냄새

이 악취들은 객체 지향 프로그래밍 원칙을 불완전하거나 잘못 적용한 결과입니다.

### 3.12 반복되는 switch 문
> Repeated Switches

1990년대 후반과 비교해서 지금은 다형성이 널리 자리 잡아서 단순히 switch문을 썼다고 해서 자동으로 검토 대상은 되지 않습니다. 게다가 분기 조건에 몇가지 기본형만 쓸 수 있던 예전과 달리, 문자열 등의 더 복잡한 타입까지 지원하는 발전된 switch문을 제공하는 언어도 많아졌죠.

그러니 이제는 똑같은 조건부 로직이 여러곳에서 반복해 등장하는 코드에 집중해봅시다. 중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 수정해야하기 때문입니다.

이럴 때 다형성은 switch문의 내뿜는 사악한 기운을 제압하여 코드베이스를 최신으로 바꿔주는 세련된 무기로 작용합니다.

### 3.16 임시 필드
> Temporary Field

간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있습니다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는게 보통이라, 이렇게 임시 필드를 갖도록하면 코드를 이해하기 어려워집니다.

이렇게 덩그러니 떨어져있는 필드를 발견하면 다음과 같은 순서로 제거해봅시다.

1. [클래스 추출하기]()로 제 살 곳을 찾아준다.
2. [함수 옮기기]()로 임시 필드와 관련된 코드를 새 클래스에 옮겨준다.
3. 임시 필드들이 유효한지 확인 후 동작하는 조건부 로직이 있다면, [특이 케이스 추가하기]()를 통해 해결한다.

### 3.21 서로 다른 인터페이스의 대안 클래스들
> Alternative Classes with Different Interfaces

클래스를 사용할 때의 강점은 필요에 따라 다른 클래스로 교체할 수 있다는 것입니다. 단, 그러기 위해서는 인터페이스가 같아야하죠.

따라서 [함수 선언 바꾸기]()를 통해 메서드 시그니처를 일치시킵니다. 이것으로 부족하다면, [함수 옮기기]()를 통해 인터페이스가 같아질 때까지 필요한 동작들을 클래스 내부에 숨깁니다. 그러다 중복 코드가 생기면 [슈퍼클래스 호출하기]()를 적용해봐도 좋겠죠.

### 3.23 상속 포기
> Refused Bequest

서브 클래스는 부모로부터 메소드와 데이터를 물려받습니다. 그치만 일부만 필요하고 일부는 필요없다면 어떻게 해야할까요?

예전에는 이를 설계를 잘못했기 때문에 생긴 문제라고 생각했습니다. 때문에 같은 계층에 서브 클래스를 하나 만들고 [메서드 내리기]()와 [필드 내리기]()를 통해 부모에는 진짜 공통적인 부분만 남기려고 노력했다하죠.

대게 공통적인 속성을 남겨놔서 재활용하는 기법은 유용하지만 지금은 해당 방식을 무조건 권하지 않습니다.

상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 납니다. 구현을 따르지 않는 것은 이해할 수 있으나 인터페이스를 따르지 않는다는 것은 문제가 생길 수 있죠.

이럴 때는 [서브클래스를 위임으로 바꾸기]() 또는 [슈퍼클래스를 위임으로 바꾸기]()를 활용해서 아예 상속에서 벗어나봅시다.

## 변경을 방해하는 냄새

이 악취들이 느껴진다면 코드의 한 부분을 변경해야 할 때, 다른 여러 곳에서도 변경을 해야합니다. 그 결과 프로그램 개발은 훨씬 더 복잡하고 비용이 많이 들게 되죠.

### 3.6 가변 데이터
> Mutable Data

데이터를 변경했더니 예상치 못한 결과가 발생하는 경우가 있습니다. 이런 문제는 드물지만, 한 번 발생하면 원인을 찾기 매우 어려울 수 있습니다.

이러한 이유로 함수형 프로그래밍에서는 데이터를 변경하지 않거나, 변경이 필요할 경우 원본 데이터의 복제본을 만들어 사용합니다. 하지만 함수형 프로그래밍을 사용하는 경우는 상대적으로 적고, 대부분의 언어에서는 변수 변경을 지원합니다.

그렇다고 해서 불변성이 주는 장점을 포기할 필요는 없습니다. 가변 데이터로 인해 발생할 수 있는 문제를 방지하는 다양한 방법이 있습니다.

- **데이터 변경을 특정 방식으로만 허용하고 싶다면**, [변수 캡슐화하기]()를 활용하여 정해진 함수만을 통해 접근하도록 제한합니다.
- **여러 가지 용도로 사용되는 변수가 있다면**, [변수 쪼개기]()를 통해 변수의 역할을 분리하여 필요한 값만 갱신하도록 만듭니다.
- **갱신 로직이 코드의 다른 부분과 뒤섞여 있다면**, [함수 추출하기]()와 [문장 슬라이스 하기]()를 적용하여 갱신 로직을 독립적으로 관리합니다.
- **API에서 데이터 변경을 최소화하고 싶다면**, [질의 함수와 변경 함수 분리하기]()를 통해 부작용이 있는 코드 호출을 제한합니다.
- **불필요한 변수 변경을 원천 차단하고 싶다면**, [세터 제거하기]()를 적용하여 값 변경이 발생하지 않도록 합니다.
- **파생 변수가 많아 관리가 어렵다면**, [파생 변수를 질의 함수로 바꾸기]()를 사용하여 계산된 값으로 대체합니다.
- **변수의 유효 범위가 넓어 관리가 어렵다면**, [여러 함수를 클래스로 묶기]() 또는 [여러 함수를 변환 함수로 묶기]()를 활용하여 변수 갱신을 특정 영역 내에서만 수행하도록 제한합니다.
- **구조체 내부 필드를 직접 수정하는 경우가 많다면**, [참조를 값으로 바꾸기]()를 통해 구조체 전체를 교체하는 방식으로 변경을 관리합니다.

### 3.7 뒤엉킨 변경
> Divergent Change

우리는 소프트웨어를 변경하기 쉬운 구조로 바꾸기 위해 노력합니다. 이는 변경 포인트를 한 군데로 두고 고립시킨다는 말입니다.

이렇게 할 수 없다면 [뒤엉킨 변경](#37-뒤엉킨-변경)과 [산탄총 수술](#38-산탄총-수술) 중 하나의 악취가 풍기는 코드이기 때문입니다.

뒤엉킨 변경은 SRP가 제대로 지켜지지 않을 때 나타납니다. 즉, 하나의 기능을 지원하기 위해 고쳐야하는 부분이 여러 군데에 있다면 이는 뒤엉킨 변경이 발생한 것입니다.

뒤엉킨 변경은 코드를 맥락별로 분리함으로 해결할 수 있습니다.

- **순차적으로 실행되는 게 자연스러운 맥락이라면**, [단계 쪼개기]()를 통해 순차적인 맥락에 맞게 구조를 분리합니다.
- **전체 처리 과정에서 각기 다른 맥락의 함수를 호출하고 있다면**, 같은 맥락을 가진 함수들을 [함수 옮기기]() 기법을 통해 모아주면 좋습니다.
- **여러 맥락을 드나드는 함수가 있다면**, [함수 추출하기]()를 통해 이를 분리합니다.
- **모듈이 클래스 단위라면**, [클래스 추출하기]()으로 맥락별로 분리합니다.

### 3.8 산탄총 수술
> Shotgun Surgery

뒤엉킨 변경이 하나의 코드에 맥락이 섞여서 발생하는 것이라면, 산탄총 수술은 반대로 여러 코드에 맥락이 흩뿌려져 있는 것을 말합니다.

변경할 부분이 코드 전반에 퍼져있다면 찾기도 어렵고 꼭 수정해야 할 곳을 놓치기 쉽습니다. 이를 해결하기 위해서는 맥락별로 코드를 모아줘야 하죠.

- **일반 적인 경우라면**, [함수 옮기기]()와 [필드 옮기기]()로 모두 한 모듈에 묶어두면 좋습니다.
- **비슷한 데이터를 다루는 함수가 많다면**, [여러 함수를 클래스로 묶기]()를 적용합니다.
- **데이터 구조를 변환하거나 보강하는 함수라면**, [여러 함수를 변환 함수로 묶기]()를 적용합니다.
- **함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달한다면**, [단계 쪼개기]()를 적용합니다.
- **어설프게 분리된 로직이라면**, [함수 인라인하기]()나 [클래스 인라인하기]()를 적용할 수 있습니다.

## 불필요한 요소의 냄새

말 그대로 코드에 숨어있는 불필요한 요소들이 내는 악취입니다. 이를 제거하면 코드가 더 깔끔하고 효율적이며 이해하기 쉬워집니다.

### 3.2 중복 코드
> Duplicate Code

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합해서 더 나은 프로그램으로 변경할 수 있습니다. 중복코드를 해결 할 땐 서로 차이점이 없는지 살펴보는 것이 중요합니다.

- 하나의 클래스 안에 두 메소드가 똑같은 표현을 한다면, [함수 추출하기]()를 적용할 수 있습니다.
- 코드가 비슷한데 완전히 똑같이 않다면, [문장 슬라이드하기]()로 비슷한 부분을 모아봅니다.
- 같은 부모에서 파생된 서브 클래스에서 중복된 메소드라면, [메소드 올리기]()를 적용합니다.

### 3.13 반복문
> Loops

반복문은 프로그래밍 언어가 등장할 때부터 함께한 핵심 프로그래밍 요소입니다.

예전에는 반복문의 대안이 없었지만 현재는 일급 함수를 지원하는 프로그래밍 언어가 많아지면서 [반복문을 파이프라인으로 바꾸기]()를 적용해 시대에 맞지 않는 반복문을 제거하는 것이 가능해졌습니다.

Filter나 Map 같은 파이프라인 연산을 사용하면 원소들이 어떻게 처리되는지 쉽게 파악할 수 있습니다.

### 3.14 성의 없는 요소
> Lazy Element

우리는 코드의 구조를 잡을 때 클래스, 메소드, 인터페이스와 같은 프로그램 요소를 이용하는 걸 좋아합니다. 이렇게 프로그래밍적 요소를 활용하면 재활용 할 수 있는 여건과 함께 의미있는 이름을 가질 수 있기 때문이죠.

그치만 이렇게 구조를 잡지 않아도 되는 경우가 있습니다. 재활용의 여지가 없는 메소드, 이름을 가지지 않아도 충분히 이해할만한 동작들, 죽은 객체인 경우 등등이 이런 경우에 속하죠.

이런 요소는 다양한 사정에 의해 생길 수 있지만 어떤 사정이든 고이 보내드리는 게 좋습니다.

- 흔한 경우, [함수 인라인하기]() 또는 [클래스 인라인하기]()을 적용합니다.
- 상속을 사용했다면 [계층 합치기]()를 적용합니다.

### 3.15 추측성 일반화
> Speculative Generality

추측성 일반화는 나중에 이게 필요할 것이라는 이유로 당장은 필요없는 코드로 인해 풍기는 악취입니다. (YAGNI)

물론 추측을 통해 기능을 확장하는 것 또한 이해할만한 내용이지만, 코드 관리가 어렵다면 쓸데없는 낭비일 뿐입니다.

그러니 당장에 쓰지 않는 코드는 모두 지워버리는 것이 좋죠.

- 하는 일이 거의 없는 클래스는, [계층 합치기]()로 제거합니다.
- 쓸데 없이 위임하는 코드는, [함수 인라인하기]()와 [클래스 인라인하기]()로 제거합니다.
- 본문에서 사용하지 않는 매개변수는, [함수 선언 바꾸기]()로 제거합니다.
- 테스트 코드에서만 사용하는 코드는, 테스트 케이스를 날리고 [죽은 코드 제거하기]()로 제거합니다.

### 3.22 데이터 클래스
> Data class

### 3.24 주석
> Comments

## 결합도의 냄새

코드에 이런 악취가 있다면 클래스 간의 지나치게 강한 결합을 초래하거나, 결합이 과도한 위임으로 대체되었을 가능성이 있습니다.

### 3.9 기능 편애
> Feature Envy

기능 편애는 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새입니다. 

흔히 Getter 메소드를 여러번 호출하면서 다른 데이터에 접근해서 상호 작용하는 일부터 함수 안에서 함수의 일부가 다른 모듈의 기능과 깊게 상호작용 하는 다양한 경우가 있습니다.

그리고 악취의 원인이 다양한 만큼 해결 방법도 다양합니다.

- 다른 데이터나 모듈의 기능을 편애하는 경우, [함수 추출하기]()로 옮겨주면 됩니다.
- 어디로 옮겨야 할지 명확하지 않은 경우, [함수 옮기기]()를 통해 관련 데이터가 가장 많은 모듈로 옮깁니다.


위에서 설명한 규칙을 거스르는 패턴도 존재합니다.

- 전략 패턴(Strategy Pattern)
- 방문자 패턴(Visitor Pattern)
- 자기 위임(Self Delegation)

위 패턴들이 사용되는 이유는 [뒤엉킨 변경](#37-뒤엉킨-변경)을 해결하기 위해 `함께 변경할 대상들을 모으는 용도`로 사용하는 것입니다. 때문에 기능 편애가 발생하기도 하죠.

데이터와 이를 활용하는 동작은 원래 한 곳에 있어야 맞지만 항상 예외는 있습니다. 이럴 때는 같은 데이터를 다루는 로직은 한 곳으로 모으는게 좋습니다.

전략 패턴과 방문자 패턴을 이용하면 오버라이딩 해야하는 특정 동작들을 각각 클래스로 격리시켜주므로 수정하기 쉬워집니다. 대신 간접 호출이 늘어나는 문제도 있죠.

### 3.17 메시지 체인
> Message Chains

메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻은 후 연속적으로 객체를 찾아나가는 과정을 이야기합니다. 예를 들어 `getSomething()`과 같은 메소드를 연속적으로 호출해 객체를 찾아가는 것이죠.

이는 클라이언트가 객체 내비게이션 구조에 종속됐음을 말합니다. 이와 같은 문제는 [위임 숨기기]()로 해결이 가능합니다.

하지만, 이 기법을 많이 사용하면 결국에 중간 객체가 중재자와 같은 역할을 하게됩니다. 그러니 최종 결과 객체가 어떻게 쓰이는지부터 살펴보는 게 좋습니다.

[함수 추출하기]()로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 [함수 옮기기]()로 체인을 옮길 수 있는지 살펴봅시다.

### 3.18 중개자
> Middle Man

객체의 대표적인 기능 중 하나로 캡슐화라는 기능이 있습니다. 캡슐화를 통해서 객체는 다른 객체에게 작업을 위임하고 구현을 몰라도 되게 됩니다.

예로 팀장과 미팅을 잡는다고 하면 팀장은 일정을 조율하고 답을 줄 것입니다. 그 일정을 잡는 과정에서 다이어리를 쓰든, 캘린더를 쓰든, 비서를 쓰든 그건 우리와는 관계 없죠.

이렇게 캡슐화를 사용하면 구현을 몰라도 원하는 바를 얻을 수 있습니다.

그치만 이게 지나치면 문제가 됩니다. 클래스의 메소드의 절반이 다른 객체에게 위임하고 있는 구조라면 그 클래스를 사용하여 기능을 구현할 땐 로직 없이 메시지만 전달하는 코드를 추가로 작성하게 됩니다.

이런 경우에는 [중개자 제거하기]()를 통해 객체와 직접적으로 소통하게 수정해줍시다.

### 3.19 내부자 거래
> insider Trading

소프트웨어 개발자는 모듈 사이에 벽을 두껍게 세우기를 좋아합니다. 이 말은 모듈 사이의 필요없는 결합을 줄이고 싶어한다는 의미죠.

- 만약에 은밀하게 모듈끼리 데이터를 주고 받고 싶다면, [필드 옮기기]()나 [함수 옮기기]()를 통해 결합을 줄이는게 좋습니다.
- 여러 모듈이 같은 관심사를 공유해서 결합하는 일이 많다면, [위임 숨기기]()를 통해 다른 모듈이 중간자의 역할을 하도록 합니다.
- 상속 구조에서 부모와 자식 클래스 간의 결합이 많다면, [서브 클래스를 위임으로 바꾸기]()나 [슈퍼클래스를 위임으로 바꾸기]()를 적용합니다.
