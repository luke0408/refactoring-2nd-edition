# Ch03. 코드에서 나는 악취

리팩터링을 `언제 시작하고 언제 그만할지`를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요합니다.

하지만 여기에는 딜레마가 있습니다. 인스턴스 변수를 삭제하거나 상속 계층을 만드는 방법을 설명하는 것은 쉬운 일에 속하죠. 하지만 이런 일들을 `언제` 해야 하느냐에 대한 것은 명확하게 정리된 것이 없습니다.

때문에 책에서도 리팩터링은 이때해야한다! 라는 명확한 기준을 제시하지 않습니다. 대신 마틴 파울러와 캔트 백은 이번 챕터를 통해 코드에서 나는 `악취`들을 소개합니다.

여기서 악취라는 것은 리팩터링의 시작과 종료 기준이 아닙니다. 다만 마치 갓난아기의 기저귀에서 나는 냄새에 따라 기저귀를 갈아줄 시점을 판단하는 것처럼, `악취의 종류`와 `악취를 리팩터링하면 해결할 수 있는 문제의 징후`를 제시하는 것이죠.

> 이 뒤로는 책에 나와있는 악취들을 한 번에 머리에 넣기 힘들어 제 나름대로 분류를 나누어 설명할 것이기 때문에 책과는 순서가 다를 수 있습니다.


## 거대해진 코드에서 나는 냄새

이 악취들은 불필요하게 불 필요하게 부풀어 오른 코드, 메서드, 클래스 등에서 나타납니다. 일반적으로 바로 나타나는 악취들이 아니라, 프로그램을 발전하면서 시간이 지남에 따라 스멀스멀 피어오르는 악취들이죠.

### 3.1 기이한 이름
> Mysterious Name <br>
> [함수 선언 바꾸기](), [변수 이름 바꾸기](), [필드 이름 바꾸기]()

추리 소설이라면 무슨 일이 전개되는지 궁금증을 자아낼수록 좋겠지만, 코드에서는 아닙니다. 코드를 명료하게 표한하는 데 가장 중요한 요소 중 하나는 바로 `이름`입니다. 

그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 해야합니다.

책에서는 더 나아가 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니라, 설계의 문제를 파악할 수 있는 열쇠로도 설명합니다.

만약 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다는 것이죠.

### 3.3 긴 함수
> Long Function

오랜 기간 잘 활용되는 함수들은 대체로 길이가 짧습니다. 이런 함수들은 코드가 끝없이 위임하는 방식으로 작성되어 있습니다. 즉, 짦은 함수로 만든다는 건 하나의 긴 함수처럼 모든 계산을 하는 것이 아니라 짧은 함수 여러개를 호출하는 구조를 말하게 되는 것이죠.

이런 구조는 코드를 이해하고, 공유하고 선택하기 쉬워진다는 장점을 가집니다.

물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다 갔다 해야 하므로 부담이 될 수 있습니다. 때문에 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름을 짓는 것 입니다.

함수 이름을 잘 지어두면 본문의 내용을 읽을 이유가 없기 때문이죠.

그러기 위해서는 훨씬 적극적으로 함수를 쪼개야합니다. 예를 들어 주석이 필요한 부분이 있다면 함수로 만드는 것이죠.

그러면 그 함수 본문에는 주석으로 설명하려던 코드가 담기고, 함수의 이름은 동작 방식이 아닌 함수의 `의도`를 담게 됩니다.

이렇게 우리는 점점 함수의 목적(의도)과 구현 코드의 괴리를 점점 줄여갈 수 있게 됩니다. 즉, `무엇을 하는지`를 코드가 잘 설명해주지 못할수록 함수로 만들어 나가는 것이죠.

단, 이런 작업은 여러 방법으로 진행될 수 있습니다.

[ 일반적인 상황 ]

일반적으론 [함수 추출하기]()을 사용하는 것 만으로 충분합니다.

[ 함수에 매개변수와 임시 변수가 너무 많은 경우 ]

이런 상황이라면 추출 작업을 하기가 어렵습니다. 이런 상황에서 바로 추출을 해버린다면, 추출된 함수에도 매개변수가 많아져 오히려 코드의 `의도`를 알기 어려워지죠.

때문에 추출하기에 앞서 먼저 `임시변수`에는 [임시변수를 질의함수로 바꾸기]()를 그리고 `매개변수`에는 [매개변수 객체 만들기]()와 [객체 통째로 넘기기]()를 통해 변수의 수를 줄여야합니다.

만약 그럼에도 변수가 너무 많다면 [함수를 명령으로 바꾸기]()를 적용해야하는 상황입니다.

[ 조건문과 Switch문 ]

조건문은 간단하게 [조건문 분해하기]()로 대응이 가능합니다.

거대한 Switch 문은 구성 case문마다 [함수 추출하기]()를 적용해서 각 case의 본문을 바꾸거나, 같은 조건을 기준으로 나뉘는 Switch문이 여러개라면 [조건문을 다형성으로 바꾸기]()를 적용할 수 있습니다.

[ 반복문 ]

반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만들 수 있습니다. 만약 추출한 반복문 코드에 적합한 이름이 떠오르지 않는다면
성격이 다른 작업이 섞여있을 가능성이 있습니다. 이땐 [반복문 쪼개기]()를 적용해서 작업을 분리합니다.


### 3.4 긴 매개변수 목록
> Long Parameter List

우리는 함수에 필요한 데이터를 함수 파라미터로 넣으라고 배웠습니다. 그래야 전역 데이터의 사용을 줄일 수 있기 때문이죠. 하지만 매개변수의 목록이 길어지면 그 자체로 이해하기 어려워집니다.

매개변수의 수를 줄이는 방법은 상황별로 다릅니다.

- 다른 매개변수에서 얻을 수 있는 값이 있다면, [매개 변수를 질의 함수로 바꾸기]()를
- 사용 중인 데이터 구조에서 값을 뽑아 넘기는 구조라면, [객체 통째로 넘기기]()를
- 항상 함께 전달되는 매개변수들이 있다면, [변수 객체로 만들기]()를
- 매개변수가 함수의 동작을 제어하는 플래그라면, [플래그 인수 제거하기]()를
- 여러 함수에서 공통적으로 사용하는 파라미터들이 있다면, [여러 함수를 클래스로 묶기]()를

위와 같이 상황별로 다른 기법을 적용할 수 있습니다.


### 3.5 전역 데이터
> Global Data

전역 데이터를 주의해야 한다는 것은 소프트웨어 개발을 처음 배우기 시작할 때부터 자주 들으셨을 겁니다.

전역 데이터는 악취 중 가장 독한 악취 중 하나입니다. 코드 베이스 어디에서나 변경이 가능하여 마치 유령 같은 원격작용처럼, 버그는 계속 발생하는데 이 변경 시점을 추적하기 힘들기 때문입니다.

전역 데이터의 가장 대표적인 형태는 `전역 변수`이지만 `클래스 변수`와 `싱글톤`에서도 같은 문제가 발생합니다.

이 문제를 해결하기 위해서는 [변수를 캡슐화]() 하여 `접근 포인트`를 제어하거나, 전역 데이터를 `불변 데이터`로 변경하면 됩니다.

### 3.10 데이터 뭉치
> Data Clumps

데이터 항목들은 어린아이 같아서 서로 어울려 놀길 좋아합니다. 그래서 서너 개가 여러 곳에서 항상 함께 뭉처 다니는 모습을 흔히 목격할 수 있죠.

특정 클래스의 필드끼리 다니거나, 한 메소드에서 파라미터로 같이 다니거나 다양한 모습으로 발견이 됩니다.

이런 데이터 뭉치들은 보금자리를 만들어 주어야합니다.

- 클래스의 특정 필드끼리 몰려다닌다면, [클래스 추출하기 기법]()으로
- 메소드의 파라미터끼리 몰려다닌다면, [매개변수 객체 만들기 기법]()이나 [객체 통째로 넘기기]()로

데이터 뭉치를 분리해줍니다.

데이터 뭉치인지 확인하는 방법은 값을 하나 지워본다고 가정하는 것입니다. 만약 나머지 데이터만으로는 의미가 없다면 객체로 환생하고 싶은 데이터라는 뜻입니다.

### 3.11 기본형 집착
> Primitive Obsession

대부분의 프로그래밍 언어에서는 기본형 타입을 지원합니다. 정수, 부동소수점 수, 문자열과 같은 기본형을 말이죠.

그래서인지 프로그래머들은 이런 기본형들을 그냥 사용는걸 선호하며 문제를 해결하기 위해 클래스로 만드는걸 꺼리는 경향이 있습니다. (화폐, 좌표, 전화번호 등)

이 냄새는 문자열을 다루는 코드에서 특히 흔하게 맡을 수 있습니다. 예를 들어 전화번호를 단순히 문자열로 바라보는 경우가 있죠.

전화번호라는 객체가 가질 수 있는 기능이 많음에도 말입니다.

그래서 이런 기본형을 객체로 바꿔주는 작업을 해야합니다.

- 단순한 기본형만 존제하는 코드라면, [기본형을 객체로 바꾸기]()를 적용
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드라면, [타입 코드를 서브클래스로 바꾸기]()와 [조건부 로직을 다형성으로 바꾸기]()를 차례로 적용
- 자주 몰려다니는 기본형 그룹이 있다면, [클래스 추출하기]()와 [매개변수 객체 만들기]()를 적용

이런 방식으로 기본형만 존재하는 구석기 동굴을 의미 있는 자료형들이 사는 문명사회로 탈바꿈 할 수 있습니다.

### 3.20 거대한 클래스
> Large Class

[ 필드가 너무 많은 클래스 ]

한 클래스가 너무 많은 일을 하려다 보면 당연하게도 필드의 수가 늘어나게 됩니다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉬워지죠.

일반적으론 [클래스 추출하기]()로 필드들 일부를 따로 묶는게 좋습니다. 주로 접두어나 접미어가 같은 필드들이 같이 추출 할 후보군이됩니다.

만약 분리할 컴포넌트를 원래 클래스와 상속 관계로 만드는게 좋다면 [슈퍼클래스 추출하기]()나 [타입 코드를 서브클래스로 바꾸기]()를 적용하는 편이 더 쉽습니다.

[ 코드량이 너무 많은 클래스 ]

필드가 많은 클래스처럼 코드량이 너무 많은 경우에도 중복 코드와 혼동을 이르킬 여지가 있습니다. 가장 간단한 해법은 자체적으로 클래스 내부의 중복을 제거하는 것 입니다.  

## 객체 지향의 냄새

이 악취들은 객체 지향 프로그래밍 원칙을 불완전하거나 잘못 적용한 결과입니다.

### 3.12 반복되는 switch 문
> Repeated Switches 

### 3.16 임시 필드
> Temporary Field

### 3.21 서로 다른 인터페이스의 대안 클래스들
> Alternative Classes with Different Interfaces

### 3.23 상속 포기
> Refused Bequest

## 변경을 방해하는 냄새

이 악취들이 느껴진다면 코드의 한 부분을 변경해야 할 때, 다른 여러 곳에서도 변경을 해야합니다. 그 결과 프로그램 개발은 훨씬 더 복잡하고 비용이 많이 들게 되죠.

### 3.6  가변 데이터
> Mutable Data 

### 3.7 뒤엉킨 변경
> Divergent Change

### 3.8 산탄총 수술
> Shotgun Surgery

## 불필요한 요소의 냄새

말 그대로 코드에 숨어있는 불필요한 요소들이 내는 악취입니다. 이를 제거하면 코드가 더 깔끔하고 효율적이며 이해하기 쉬워집니다.

### 3.2 중복 코드
> Duplicate Code

### 3.13 반복문
> Loops

### 3.14 성의 없는 요소
> Lazy Element

### 3.15 추측성 일반화
> Speculative Generality

### 3.22 데이터 클래스
> Data class

### 3.24 주석
> Comments

## 결합도의 냄새

코드에 이런 악취가 있다면 클래스 간의 지나치게 강한 결합을 초래하거나, 결합이 과도한 위임으로 대체되었을 가능성이 있습니다.

### 3.9 기능 편애
> Feature Envy

### 3.17 메시지 체인
> Message Chains

### 3.18 중개자
> Middle Man

### 3.19 내부자 거래
> insider Trading